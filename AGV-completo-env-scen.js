// Environment and Scenario Module for AGV-completo
// Auto-generated by SysADL Transformer - Hybrid Implementation
const { EnvironmentDefinition, EnvironmentConfiguration, Entity, Event, Scene, Scenario, ScenarioExecution, EventsDefinitions, SceneDefinitions, ScenarioDefinitions, Connection } = require('../sysadl-framework/SysADLBase');
const { TaskExecutor } = require('../sysadl-framework/TaskExecutor');
const { createModel } = require('./AGV-completo');

// Entity: Station
class Station extends Entity {
  constructor(name, opts = {}) {
    // Initialize default properties structure
    const defaultProperties = {};
    defaultProperties.ID = null; // Type: String
    defaultProperties.signal = null; // Type: Object
    
    // Merge with provided properties (EnvironmentConfiguration values)
    const mergedProperties = { ...defaultProperties, ...(opts.properties || {}) };
    
    super(name, {
      ...opts,
      entityType: 'Station',
      properties: mergedProperties,
      roles: ["signal"]
    });
    
  }
}

// Entity: PartX
class PartX extends Entity {
  constructor(name, opts = {}) {
    // Initialize default properties structure
    const defaultProperties = {};
    defaultProperties.ID = null; // Type: String
    defaultProperties.location = null; // Type: String
    defaultProperties.surface = null; // Type: Object
    
    // Merge with provided properties (EnvironmentConfiguration values)
    const mergedProperties = { ...defaultProperties, ...(opts.properties || {}) };
    
    super(name, {
      ...opts,
      entityType: 'PartX',
      properties: mergedProperties,
      roles: ["surface"]
    });
    
  }
}

// Entity: Lane
class Lane extends Entity {
  constructor(name, opts = {}) {
    const mergedProperties = opts.properties || {};
    
    super(name, {
      ...opts,
      entityType: 'Lane',
      properties: mergedProperties,
      roles: []
    });
    
  }
}

// Entity: Supervisory
class Supervisory extends Entity {
  constructor(name, opts = {}) {
    // Initialize default properties structure
    const defaultProperties = {};
    defaultProperties.inNotification = null; // Type: Object
    defaultProperties.outCommand = null; // Type: Object
    
    // Merge with provided properties (EnvironmentConfiguration values)
    const mergedProperties = { ...defaultProperties, ...(opts.properties || {}) };
    
    super(name, {
      ...opts,
      entityType: 'Supervisory',
      properties: mergedProperties,
      roles: ["inNotification","outCommand"]
    });
    
  }
}

// Entity: Vehicle
class Vehicle extends Entity {
  constructor(name, opts = {}) {
    // Initialize default properties structure
    const defaultProperties = {};
    defaultProperties.location = null; // Type: String
    defaultProperties.outNotification = null; // Type: Object
    defaultProperties.inCommand = null; // Type: Object
    defaultProperties.sensor = null; // Type: Object
    defaultProperties.arm = null; // Type: Object
    
    // Merge with provided properties (EnvironmentConfiguration values)
    const mergedProperties = { ...defaultProperties, ...(opts.properties || {}) };
    
    super(name, {
      ...opts,
      entityType: 'Vehicle',
      properties: mergedProperties,
      roles: ["outNotification","inCommand","sensor","arm"]
    });
    
  }
}

// Connection: Notify
class Notify extends Connection {
  constructor(name = 'Notify', opts = {}) {
    super(name, {
      ...opts,
      connectionType: 'connection',
      from: 'Vehicle.outNotification',
      to: 'Supervisory.inNotification'
    });
  }
}

// Connection: Command
class Command extends Connection {
  constructor(name = 'Command', opts = {}) {
    super(name, {
      ...opts,
      connectionType: 'connection',
      from: 'Supervisory.outCommand',
      to: 'Vehicle.inCommand'
    });
  }
}

// Connection: Location
class Location extends Connection {
  constructor(name = 'Location', opts = {}) {
    super(name, {
      ...opts,
      connectionType: 'connection',
      from: 'Station.signal',
      to: 'Vehicle.sensor'
    });
  }
}

// Connection: Atach
class Atach extends Connection {
  constructor(name = 'Atach', opts = {}) {
    super(name, {
      ...opts,
      connectionType: 'connection',
      from: 'Vehicle.arm',
      to: 'PartX.surface'
    });
  }
}

// Connection: Detach
class Detach extends Connection {
  constructor(name = 'Detach', opts = {}) {
    super(name, {
      ...opts,
      connectionType: 'connection',
      from: 'Vehicle.arm',
      to: 'PartX.surface'
    });
  }
}

// Environment Definition: MyFactory
class MyFactory extends EnvironmentDefinition {
  constructor() {
    super('MyFactory');
    
    // Register entity classes for factory usage
    this.registerEntityClass('Station', Station);
    this.registerEntityClass('PartX', PartX);
    this.registerEntityClass('Lane', Lane);
    this.registerEntityClass('Supervisory', Supervisory);
    this.registerEntityClass('Vehicle', Vehicle);
    
    // Register connection classes for factory usage
    this.registerConnectionClass('Notify', Notify);
    this.registerConnectionClass('Command', Command);
    this.registerConnectionClass('Location', Location);
    this.registerConnectionClass('Atach', Atach);
    this.registerConnectionClass('Detach', Detach);
    // Connector definitions metadata
    this.connectors = [
      {
        name: 'Notify',
        from: 'Vehicle.outNotification',
        to: 'Supervisory.inNotification'
      },
      {
        name: 'Command',
        from: 'Supervisory.outCommand',
        to: 'Vehicle.inCommand'
      },
      {
        name: 'Location',
        from: 'Station.signal',
        to: 'Vehicle.sensor'
      },
      {
        name: 'Atach',
        from: 'Vehicle.arm',
        to: 'PartX.surface'
      },
      {
        name: 'Detach',
        from: 'Vehicle.arm',
        to: 'PartX.surface'
      },
    ];
  }
}

// Environment Configuration: MyFactoryConfiguration
class MyFactoryConfiguration extends EnvironmentConfiguration {
  constructor() {
    const environmentDefinition = new MyFactory();
    super('MyFactoryConfiguration', { environmentDef: environmentDefinition });
    
    // Associations (role bindings)
    this.associations = {
      "Vehicle.outNotification": "agvs.in_outDataAgv.outNotifications",
      "Vehicle.inCommand": "agvs.in_outDataAgv.inMoveToStation",
      "Vehicle.sensor": "agvs.as.arrivalDetected",
      "Vehicle.arm": "agvs.ra.start",
      "Supervisory.inNotification": "ss.in_outDataS.inNotifications",
      "Supervisory.outCommand": "ss.in_outDataS.outMoveToStation"
    };
    
    // Entity instances
    this.agv1 = this.createEntity('Vehicle', {"name":"agv1"});
    this.agv2 = this.createEntity('Vehicle', {"name":"agv2"});
    this.stationA = this.createEntity('Station', {"name":"stationA","properties":{"ID":"StationA"}});
    this.stationB = this.createEntity('Station', {"name":"stationB","properties":{"ID":"StationB"}});
    this.stationC = this.createEntity('Station', {"name":"stationC","properties":{"ID":"StationC"}});
    this.stationD = this.createEntity('Station', {"name":"stationD","properties":{"ID":"StationD"}});
    this.stationE = this.createEntity('Station', {"name":"stationE","properties":{"ID":"StationE"}});
    this.supervisor = this.createEntity('Supervisory', {"name":"supervisor"});
    this.part = this.createEntity('PartX', {"name":"part"});
    this.lane1 = this.createEntity('Lane', {"name":"lane1","properties":{"entities":{"type":"ArrayLiteralExpression","elements":["stationA","stationB","stationC"],"location":{"source":{"source":"/Users/tales/desenv/SysAdlWebStudio/tales/v0.5/AGV-completo.sysadl","text":"Model SysADLArchitecture;\npackage SysADL.types {\n\tvalue type Int {\n\t}\n\tvalue type Boolean {\n\t}\n\tvalue type String {\n\t}\n\tvalue type Void {\n\t}\n\tvalue type Real {\n\t}\n\tenum NotificationToSupervisory {\n\t\tdeparted, arrived, passed, traveling\n\t}\n\tenum NotificationFromArm {\n\t\tloaded, unloaded\n\t}\n\tenum CommandToArm {\n\t\tload, unload, idle\n\t}\n\tenum NotificationFromMotor {\n\t\tstarted, stopped\n\t}\n\tenum CommandToMotor {\n\t\tstart, stop\n\t}\n\tdatatype Status {\n\t\tattributes: location : Location;\n\t\tdestination : Location;\n\t\tcommand : CommandToArm;\n\t}\n\tdatatype Location{\n\t\tattributes: location : String;\n\t}\n\tdatatype VehicleData{\n\t\tattributes: destination : Location;\n\t\tcommand : CommandToArm;\n\t}\n}\npackage PortsAGV {\n\timport SysADL.types;\n\tport def inLocation {\n\t\tflow in Location\n\t}\n\tport def outLocation {\n\t\tflow out Location\n\t}\n\tport def inStatus {\n\t\tflow in Status\n\t}\n\tport def outStatus {\n\t\tflow out Status\n\t}\n\tport def inVehicleData {\n\t\tflow in VehicleData\n\t}\n\tport def outVehicleData {\n\t\tflow out VehicleData\n\t}\n\tport def inNotificationFromMotor {\n\t\tflow in NotificationFromMotor\n\t}\n\tport def outNotificationFromMotor {\n\t\tflow out NotificationFromMotor\n\t}\n\tport def inCommandToMotor {\n\t\tflow in CommandToMotor\n\t}\n\tport def outCommandToMotor {\n\t\tflow out CommandToMotor\n\t}\n\tport def inNotificationFromArm {\n\t\tflow in NotificationFromArm\n\t}\n\tport def outNotificationFromArm {\n\t\tflow out NotificationFromArm\n\t}\n\tport def inCommandToArm {\n\t\tflow in CommandToArm\n\t}\n\tport def outCommandToArm {\n\t\tflow out CommandToArm\n\t}\n\tport def inNotificationToSupervisory {\n\t\tflow in NotificationToSupervisory\n\t}\n\tport def outNotificationToSupervisory {\n\t\tflow out NotificationToSupervisory\n\t}\n\tport def IAGVSystem {\n\t\tports: inMoveToStation : inVehicleData {\n\t\t}\n\t\toutNotifications : outNotificationToSupervisory {\n\t\t}\n\t}\n\tport def ISupervisorySystem {\n\t\tports: outMoveToStation : outVehicleData {\n\t\t}\n\t\tinNotifications : inNotificationToSupervisory {\n\t\t}\n\t}\n}\npackage ConnectorsAGV {\n\timport PortsAGV;\n\tconnector def notifySupervisory {\n\t\tparticipants: ~ nsIPT : inNotificationToSupervisory {\n\t\t}\n\t\t~ nsOPT : outNotificationToSupervisory {\n\t\t}\n\t\tflows: NotificationToSupervisory from nsOPT to nsIPT\n\t}\n\tconnector def sendVehicleData {\n\t\tparticipants: ~ vdOPT : outVehicleData {\n\t\t}\n\t\t~ vdIPT : inVehicleData {\n\t\t}\n\t\tflows: VehicleData from vdOPT to vdIPT\n\t}\n\tconnector def notificationMotor {\n\t\tparticipants: ~ nmOPT : outNotificationFromMotor {\n\t\t}\n\t\t~ nmIPT : inNotificationFromMotor {\n\t\t}\n\t\tflows: NotificationFromMotor from nmOPT to nmIPT\n\t}\n\tconnector def commandArm {\n\t\tparticipants: ~ caOPT : outCommandToArm {\n\t\t}\n\t\t~ caIPT : inCommandToArm {\n\t\t}\n\t\tflows: CommandToArm from caOPT to caIPT\n\t}\n\tconnector def notificationArm {\n\t\tparticipants: ~ naIPT : inNotificationFromArm {\n\t\t}\n\t\t~ naOPT : outNotificationFromArm {\n\t\t}\n\t\tflows: NotificationFromArm from naOPT to naIPT\n\t}\n\tconnector def commandMotor {\n\t\tparticipants: ~ cmOPT : outCommandToMotor {\n\t\t}\n\t\t~ cmIPT : inCommandToMotor {\n\t\t}\n\t\tflows:  CommandToMotor from  cmOPT to cmIPT\n\t}\n\tconnector def interactionAGVAndSupervisory {\n\t\tparticipants: ~ iagvs : IAGVSystem {\n\t\t}\n\t\t~ iss : ISupervisorySystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tconnectors:\n\t\t\tnS : notifySupervisory bindings  outNotifications = inNotifications; \n\t\t\tsVD : sendVehicleData bindings outMoveToStation = inMoveToStation;\n\t\t}\n\t}\n\tconnector def locationVehicle {\n\t\tparticipants: ~ lOPT : outLocation {\n\t\t}\n\t\t~ lIPT : inLocation {\n\t\t}\n\t\tflows: Location from lOPT to lIPT\n\t}\n\tconnector def status {\n\t\tparticipants: ~ sOPT : outStatus {\n\t\t}\n\t\t~ sIPT : inStatus {\n\t\t}\n\t\tflows: Status from sOPT to sIPT\n\t}\n}\npackage ComponentsAGV {\n\timport PortsAGV;\n\timport ConnectorsAGV;\n\timport SysADL.types;\n\tcomponent def FactoryAutomationSystem {\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tss : SupervisorySystem {\n\t\t\t\tusing ports: in_outDataS : ISupervisorySystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tagvs : AGVSystem [ 1, -1 ] {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tin_outDataAgv : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tds : DisplaySystem {\n\t\t\t\tusing ports: receiveStatus : inStatus {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdataExchange : interactionAGVAndSupervisory bindings in_outDataS = in_outDataAgv;\n\t\t\tupdateStatus : status bindings sendStatus = receiveStatus;\n\t\t}\n\t}\n\tboundary component def DisplaySystem {\n\t\tports: receiveStatus : inStatus {\n\t\t}\n\t}\n\tboundary component def SupervisorySystem {\n\t\tports: in_outData : ISupervisorySystem {\n\t\t}\n\t}\n\tcomponent def AGVSystem {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tm : Motor {\n\t\t\t\tusing ports: start_stop_in : inCommandToMotor {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_out : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tas : ArrivalSensor {\n\t\t\t\tusing ports: arrivalDetected_out : outLocation {\n\t\t\t\t}\n\t\t\t}\n\t\t\tra : RobotArm {\n\t\t\t\tusing ports: start : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tstarted : outNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvc : VehicleControl {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tarrivalDetected_in : inLocation {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tstartedArm : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_in : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstart_stop_out : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tin_outData : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tarrived : locationVehicle bindings arrivalDetected_out = arrivalDetected_in; \n\t\t\tackArm : notificationArm bindings started = startedArm; \n\t\t\tcmdArm : commandArm bindings startArm = start;\n\t\t\tackMotor : notificationMotor bindings started_stopped_out = started_stopped_in;\n\t\t\tcmdMotor : commandMotor bindings  start_stop_out = start_stop_in;\n\t\t\tdelegations:\n\t\t\t sendStatus to sendStatus \n\t\t\tin_outData to in_outData\n\t\t}\n\t}\n\tboundary component def RobotArm {\n\t\tports: start : inCommandToArm {\n\t\t}\n\t\tstarted : outNotificationFromArm {\n\t\t}\n\t}\n\tboundary component def Motor {\n\t\tports: start_stop : inCommandToMotor {\n\t\t}\n\t\tstarted_stopped : outNotificationFromMotor {\n\t\t}\n\t}\n\tboundary component def ArrivalSensor {\n\t\tports: arrivalDetected : outLocation {\n\t\t}\n\t}\n\tcomponent def VehicleControl {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t\tstartedArm : inNotificationFromArm {\n\t\t}\n\t\tstarted_stopped : inNotificationFromMotor {\n\t\t}\n\t\tstart_stop : outCommandToMotor {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tcs : CheckStation {\n\t\t\t\tusing ports: ack_cs : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tlocation_cs : outLocation {\n\t\t\t\t}\n\t\t\t\tdestination_cs : inLocation {\n\t\t\t\t}\n\t\t\t\tstop : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tarrivalDetected : inLocation {\n\t\t\t\t}\n\t\t\t\tpassed : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t}\n\t\t\tca : ControlArm {\n\t\t\t\tusing ports: cmd_ca : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tack_ca : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tnm : NotifierMotor {\n\t\t\t\tusing ports: inAck : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tack : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\toutAck : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tsm : StartMoving {\n\t\t\t\tusing ports: move : inVehicleData {\n\t\t\t\t}\n\t\t\t\tcmd_sm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tdestination : outLocation {\n\t\t\t\t}\n\t\t\t\tstart : outCommandToMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tna : NotifierArm {\n\t\t\t\tusing ports: arrivedStatus : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\tloaded_unloaded : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvt : VehicleTimer {\n\t\t\t\tusing ports: AGVStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tlocation_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tdestination_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tcmd : inCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdestinationStation2 : locationVehicle bindings destination = destination_vt; \n\t\t\tdestinationStation : locationVehicle bindings destination = destination_cs;\n\t\t\tcommand : commandArm bindings cmd_sm = cmd;\n\t\t\tcommand2 : commandArm bindings cmd_sm = cmd_ca;\n\t\t\tcurrentLocation : locationVehicle bindings location_cs = location_vt;\n\t\t\tsendNotificationMotor : notificationMotor bindings outAck = ack_ca;\n\t\t\tsendNotificationMotor2 : notificationMotor bindings outAck = ack_cs;\n\t\t\tdelegations:\n\t\t\tack to outNotifications\n\t\t\tarrivedStatus to outNotifications\n\t\t\tmove to inMoveToStation\n\t\t\tpassed to outNotifications\n\t\t\tloaded_unloaded to startedArm\n\t\t\tinAck to started_stopped\n\t\t\tstartArm to startArm \n\t\t\tAGVStatus to sendStatus \n\t\t\tstart to start_stop \n\t\t\tstop to start_stop \n\t\t\tarrivalDetected to arrivalDetected \n\t\t}\n\t}\n\tcomponent def VehicleTimer {\n\t\tports: AGVStatus : outStatus {\n\t\t}\n\t\tlocation : inLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tcmd : inCommandToArm {\n\t\t}\n\t}\n\tcomponent def NotifierArm {\n\t\tports: arrivedStatus : outNotificationToSupervisory {\n\t\t}\n\t\tloaded_unloaded : inNotificationFromArm {\n\t\t}\n\t}\n\tcomponent def ControlArm {\n\t\tports: cmd : inCommandToArm {\n\t\t}\n\t\tack : inNotificationFromMotor {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t}\n\tcomponent def CheckStation {\n\t\tports: ack : inNotificationFromMotor {\n\t\t}\n\t\tlocation : outLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tstop : outCommandToMotor {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tpassed : outNotificationToSupervisory {\n\t\t}\n\t}\n\tcomponent def NotifierMotor {\n\t\tports: inAck : inNotificationFromMotor {\n\t\t}\n\t\tack : outNotificationToSupervisory {\n\t\t}\n\t\toutAck : outNotificationFromMotor {\n\t\t}\n\t}\n\tcomponent def StartMoving {\n\t\tports: move : inVehicleData {\n\t\t}\n\t\tcmd : outCommandToArm {\n\t\t}\n\t\tdestination : outLocation {\n\t\t}\n\t\tstart : outCommandToMotor {\n\t\t}\n\t}\nactivity def StartMovingAC ( move : VehicleData) : (cmd : CommandToArm, destination : Location, start : CommandToMotor) {\n\t\tbody {\n\t\tactions : sc : SendCommandAN {\n\t\t\t\tusing pins: moveSC : VehicleData;\n\t\t\t}\n\t\t\tsd : SendDestinationAN {\n\t\t\t\tusing pins: moveSD : VehicleData;\n\t\t\t}\n\t\t\tssm : SendStartMotorAN {\n\t\t\t\tusing pins: moveSSM : VehicleData;\n\t\t\t}\n\t\t\tdelegate destination to sc \n\t\t\tdelegate cmd to sd \n\t\t\tdelegate start to ssm\n\t\t\tdelegate move to moveSD \n\t\t\tdelegate move to moveSC \n\t\t\tdelegate move to moveSSM\n\t\t}\n\t}\naction def SendStartMotorAN ( move : VehicleData ) : CommandToMotor {\n\tconstraint : post-condition SendStartMotorEQ\n\t\tdelegate SendStartMotorAN to cmd\n\t}\n\taction def SendCommandAN ( move : VehicleData ) : CommandToArm {\n\tconstraint : post-condition SendCommandEQ\n\tdelegate SendCommandAN to cmd delegate move to move\n\t}\n\taction def SendDestinationAN ( move : VehicleData ) : Location {\n\tconstraint : post-condition SendDestinationEQ\n\tdelegate SendDestinationAN to destination delegate move to move\n\t}\n\tactivity def NotifierMotorAC ( inStatusMotor : NotificationFromMotor ) : (outStatusMotor : NotificationFromMotor, ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : nagvm : NotifyAGVFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tnsm : NotifySupervisoryFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate outStatusMotor to nagvm delegate ack to nsm delegate inStatusMotor\n\t\t\tto statusMotor delegate inStatusMotor to statusMotor\n\t\t}\n\t}\n\taction def NotifyAGVFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationFromMotor {\n\tconstraint : post-condition NotifyAGVFromMotorEQ\n\tdelegate NotifyAGVFromMotorAN to outStatusMotor delegate\n\t\tstatusMotor to inStatusMotor\n\t}\n\taction def NotifySupervisoryFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifySupervisoryFromMotorEQ\n\tdelegate NotifySupervisoryFromMotorAN to ack\n\t\tdelegate statusMotor to statusMotor\n\t}\n\tactivity def CheckStationAC ( statusMotor : NotificationFromMotor ) ( destination : Location ) ( inLocation : Location ) : (stopMotor :\n\tCommandToMotor, outLocation : Location, passed : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : cs : CompareStationsAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor; \n\t\t\t\tdestination : Location; location : Location;\n\t\t\t}\n\t\t\tscl : SendCurrentLocationAN {\n\t\t\t\tusing pins: location : Location;\n\t\t\t}\n\t\t\tsm : StopMotorAN {\n\t\t\t\tusing pins: comparisonResultSM : Boolean;\n\t\t\t}\n\t\t\tpm : PassedMotorAN {\n\t\t\t\tusing pins: comparisonResultPM : Boolean;\n\t\t\t}\n\t\t\tdelegate statusMotor to NotificationsMotor \n\t\t\tdelegate destination to\tDestinations \n\t\t\tflow from NotificationsMotor to statusMotor \n\t\t\tflow from Destinations to destination \n\t\t\tdelegate inLocation to location delegate\n\t\t\toutLocation to scl delegate inLocation to location \n\t\t\tdelegate stopMotor to sm \n\t\t\tdelegate passed to pm \n\t\t\tflow from cs to comparisonResultPM\n\t\t\tflow from cs to comparisonResultSM\n\t\t\tdatastore NotificationsMotor : NotificationFromMotor {\n\t\t\t}\n\t\t\tdatastore Destinations : Location {\n\t\t\t}\n\t\t}\n\t}\n\taction def CompareStationsAN ( statusMotor : NotificationFromMotor, destination : Location, location : Location ) : Boolean {\n\tconstraint : post-condition CompareStationsEQ pre-condition NotificationMotorIsStartedEQ\n\tdelegate CompareStationsAN to result delegate location to\n\t\tloc delegate destination to dest\n\t\tdelegate statusMotor to statusMotor\n\t}\n\taction def StopMotorAN ( comparisonResult : Boolean ) : CommandToMotor {\n\tconstraint : post-condition StopMotorEQ\n\tdelegate comparisonResult to result delegate StopMotorAN to cmd\n\t}\n\taction def PassedMotorAN ( comparisonResult : Boolean ) : NotificationToSupervisory {\n\tconstraint : post-condition PassedMotorEQ\n\tdelegate PassedMotorAN to ack delegate comparisonResult to result\n\t}\n\taction def SendCurrentLocationAN ( location : Location ) : Location {\n\tconstraint : post-condition SendCurrentLocationEQ\n\tdelegate location to inLocation delegate\n\t\tSendCurrentLocationAN to outLocation\n\t}\n\tactivity def ControlArmAC ( cmd : CommandToArm ) ( statusMotor : NotificationFromMotor ) : (startArm : CommandToArm) {\n\t\tbody {\n\t\tactions : ca : ControlArmAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tstatusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate startArm to ca delegate cmd to cmd delegate statusMotor to statusMotor\n\t\t}\n\t}\n\tactivity def NotifierArmAC ( statusArm : NotificationFromArm ) :\n\t(ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : na : NotifierArmAN {\n\t\t\t\tusing pins: statusArm : NotificationFromArm;\n\t\t\t}\n\t\t\tdelegate ack to na delegate statusArm to statusArm\n\t\t}\n\t}\n\tactivity def VehicleTimerAC ( destination : Location ) ( location : Location ) ( cmd : CommandToArm ) : (status : Status) {\n\t\tbody {\n\t\tactions : vt : VehicleTimerAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tdestination : Location;\n\t\t\t\tlocation : Location;\n\t\t\t}\n\t\t\tdelegate status to vt delegate cmd to cmd delegate destination to\n\t\t\tdestination delegate location to location\n\t\t}\n\t}\n\taction def ControlArmAN ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) : CommandToArm {\n\tconstraint : post-condition ControlArmEQ\n\tdelegate ControlArmAN to startArm delegate statusMotor to\n\t\tstatusMotor delegate cmd to cmd\n\t}\n\taction def NotifierArmAN ( statusArm : NotificationFromArm ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifierArmEQ\n\tdelegate NotifierArmAN to ack\n\t}\n\taction def VehicleTimerAN ( destination : Location, location : Location, cmd : CommandToArm ) : Status {\n\tconstraint : post-condition VehicleTimerEQ\n\tdelegate VehicleTimerAN to s delegate location to\n\t\tloc delegate destination to dest delegate cmd\n\t\tto cmd\n\t}\n\tconstraint SendStartMotorEQ () : \n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = cmd ==  CommandToMotor::start\n\t\t}\n\tconstraint SendDestinationEQ ( move : VehicleData ) :\n\t\t(destination : Location) {\n\t\t\tequation = destination == move->destination\n\t\t}\n\tconstraint NotifyAGVFromMotorEQ ( inStatusMotor : NotificationFromMotor ) :\n\t\t(outStatusMotor : NotificationFromMotor) {\n\t\t\tequation = outStatusMotor == inStatusMotor\n\t\t}\n\tconstraint SendCommandEQ ( move : VehicleData ) :\n\t\t(cmd : CommandToArm) {\n\t\t\tequation = cmd == move->command\n\t\t}\n\tconstraint NotifySupervisoryFromMotorEQ ( statusMotor : NotificationFromMotor ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started ? \n\t\t\tack == NotificationToSupervisory::departed : \n\t\t\tack == NotificationToSupervisory::traveling\n\t\t}\n\tconstraint NotificationMotorIsStartedEQ (statusMotor : NotificationFromMotor) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started\n\t\t}\n\tconstraint CompareStationsEQ ( dest : Location, loc : Location ) :\n\t\t(result : Boolean) {\n\t\t\tequation = dest == loc ? result == true : result == false\n\t\t}\n\tconstraint StopMotorEQ ( result : Boolean ) :\n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = result == true ? cmd == CommandToMotor::stop : cmd == SysADL.types.Void\n\t\t}\n\tconstraint PassedMotorEQ ( result : Boolean ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = result == false ? ack == NotificationToSupervisory::passed : ack == SysADL.types.Void\n\t\t}\n\tconstraint SendCurrentLocationEQ ( inLocation : Location ) :\n\t\t(outLocation : Location) {\n\t\t\tequation = outLocation == inLocation\n\t\t}\n\tconstraint ControlArmEQ ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) :\n\t\t(startArm : CommandToArm) {\n\t\t\tequation = statusMotor == NotificationFromMotor::stopped ?\n\t\t\tstartArm == cmd : startArm == CommandToArm::idle\n\t\t}\n\tconstraint NotifierArmEQ () :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = ack == NotificationToSupervisory::arrived\n\t\t}\n\tconstraint VehicleTimerEQ ( dest : Location, loc : Location, cmd : CommandToArm ) :\n\t\t(s : Status) {\n\t\t\tequation = s->destination == dest && s->location == loc && s->command == cmd\n\t\t}\n\texecutable def SendStartMotorEX ( in move : VehicleData) : out CommandToMotor {\n\t\treturn CommandToMotor::start;\n\t}\n\texecutable def SendCommandEX ( in move : VehicleData) : out CommandToArm {\n\t\treturn move->command;\n\t}\n\texecutable def SendDestinationEX ( in move : VehicleData) : out Location {\n\t\treturn move->destination;\n\t}\n\texecutable def NotifyAGVFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\tout NotificationFromMotor{\n\t\treturn statusMotor;\n\t}\n\texecutable def NotifySupervisoryFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\t\tout\tNotificationToSupervisory {\n\t\tif (statusMotor == NotificationFromMotor::started) \n\t\t\treturn NotificationToSupervisory::departed;\n\t\telse\n\t\t\treturn NotificationToSupervisory::traveling;\n\t}\n\texecutable def CompareStationsEX ( in destination : Location, in location : Location, \n\t\tin statusMotor : NotificationFromMotor) : \tout Boolean {\n\t\tif(statusMotor == NotificationFromMotor::started && destination == location)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\texecutable def StopMotorEX ( in comparisonResult : Boolean) :\n\tout CommandToMotor {\n\t\tif(comparisonResult == true)\n\t\t\treturn CommandToMotor::stop;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def PassedMotorEX ( in comparisonResult : Boolean) :\n\tout NotificationToSupervisory {\n\t\tif(comparisonResult == false)\n\t\t\treturn NotificationToSupervisory::passed;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def SendCurrentLocationEX ( in location : Location)\n\t: out Location {\n\t\treturn location;\n\t}\n\texecutable def ControlArmEX ( in statusMotor : NotificationFromMotor, in cmd : CommandToArm) : out CommandToArm {\n\t\tif(statusMotor == NotificationFromMotor::stopped)\n\t\t\treturn cmd;\n\t\telse\n\t\t\treturn CommandToArm::idle;\n\t}\n\texecutable def NotifierArmEX ( in statusArm : NotificationFromArm) : \n\tout\tNotificationToSupervisory {\n\t\treturn NotificationToSupervisory::arrived;\n\t}\n\texecutable def VehicleTimerEX ( in location : Location, in cmd : CommandToArm, \n\t\tin destination : Location) : out Status {\n\t\t\n\t\tlet s : Status;\n\t\ts->destination = destination;\n\t\ts->location = location;\n\t\ts->command = cmd;\n\t\t\n\t\treturn s;\n\t}\n}\nRequirement RequestMove ( 1.0 ) {\n\ttext = \"The external Supervisory System sends a \\\"Move\\\" command to the AGV System requesting it to move to a factory station and load/unload a part.\"\n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ReceiveNotifications ( 1.1 ) {\n\ttext = \"The Supervisory System should receive the AGV system notifications.\" \n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ControlLoadingUnloading ( 2.0 ) {\n\ttext = \"The AGV system must control the loading and unloading of parts between stations factory, interacting with Supervisory and Display Systems.\"\n\tsatisfied by ComponentsAGV.AGVSystem;\n\tRequirement MoveToStation ( 2.1 ) {\n\t\ttext = \"An AGV can move along a track in the factory in a clockwise direction, and start and stop at factory stations.\"\n\t\tRequirement CommandMotorStartMove ( 2.2 ) {\n\t\t\ttext = \"The AGV System sends a \\\"Start Motor\\\" command to Motor to start moving.\"\n\t\t\tsatisfied by ComponentsAGV.StartMoving;\n\t\t}\n\t\tRequirement SendStartedAcknowledgement ( 2.3 ) {\n\t\t\ttext = \"Motor sends \\\"Started\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement DetectArrived ( 2.4 ) {\n\t\t\ttext = \"The arrival sensor must detect that it has arrived at the factory station and notifies the AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.ArrivalSensor;\n\t\t}\n\t\tRequirement CheckDestination ( 2.5 ) {\n\t\t\ttext = \"The AGV System checks if the current station is the arrival station.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement CommandMotorStopMove ( 2.6 ) {\n\t\t\ttext = \"If this station is the destination station, the AGV System sends \\\"Stop Moto\\\" message to Motor, else the vehicle passes the station without stopping.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement SendStoppedAcknowledgement ( 2.7 ) {\n\t\t\ttext = \"Motor sends \\\"Stopped\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement CommandLoadUnload ( 2.8 ) {\n\t\t\ttext = \"The AGV System sends \\\"Load/Unload\\\" message to Robot Arm.\"\n\t\t\tsatisfied by ComponentsAGV.ControlArm;\n\t\t}\n\t\tRequirement SendAcknowledgement ( 2.9 ) {\n\t\t\ttext = \"Robot Arm sends;Load/Unload acknowledge message to AGV System indicating that the arm has finished.\"\n\t\t\tsatisfied by ComponentsAGV.RobotArm;\n\t\t}\n\t\tRequirement NotifySupervisorySystem ( 2.10 ) {\n\t\t\ttext = \"The AGV System must notify the supervisory system when the vehicle start moving or get to a station.\"\n\t\t}\n\t}\n\tRequirement SendVehicleStatus ( 2.13 ) {\n\t\ttext = \"The AGV system should send vehicle status to an external Display System every 30 seconds.\"\n\t\tsatisfied by ComponentsAGV.VehicleTimer;\n\t}\n}\nRequirement NotifyFromMotor ( 2.11 ) {\n\ttext = \"The AGV System must send a \\\"Departed\\\" message to the Supervisory System when vehicle start moving and a \\\"Passed\\\" message when vehicle come to a different station of destination station.\"\n\tsatisfied by ComponentsAGV.NotifierMotor;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement NotifyFromArm ( 2.12 ) {\n\ttext = \"The AGV System must send a \\\"Arrived\\\" message when the part has been loaded/unloaded.\"\n\tsatisfied by ComponentsAGV.NotifierArm;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement ReceiveVehicleStatus ( 3.0 ) {\n\ttext = \"The Display System must receive of AGV system the vehicle status.\"\n\tsatisfied by ComponentsAGV.DisplaySystem;\n}\n\n\nEnvironmentDefinition MyFactory {\n\n\tEnvComponent def Station {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t}\n\t\tenvPorts {\n\t\t\tEnvPort def signal \n\t\t}\n\t}\n\n\tEnvComponent def PartX {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t\tProperty def location\n\t\t}\n\t\tenvPorts {\n\t\t\tEnvPort def surface \n\t\t}\n\t}\n\n\tEnvComponent def Lane {\n\t\tenvComponents {\n\t\t\tstations: Station[],\n\t\t\tvehicles: Vehicle[],\n\t\t\tpartx: PartX\n\t\t}\n\t}\n\n\tEnvComponent def Supervisory {\n\t\tenvPorts {\n\t\t\tEnvPort def inNotification   \n\t\t\tEnvPort def outCommand   \n\t\t}\n\t}\n\n\tEnvComponent def Vehicle {\n\t\tenvPorts {\n\t\t\tEnvPort def outNotification \n\t\t\tEnvPort def inCommand  \n\t\t\tEnvPort def sensor  \t\n\t\t\tEnvPort def arm  \n\t\t}\n\t\tproperties {\n\t\t\tProperty def location\n\t\t}\n\t}\n\n\tEnvConnector def Notify {\n\t\tfrom Vehicle.outNotification to Supervisory.inNotification\n\t}\n\t\n\tEnvConnector def Command {\n\t\tfrom Supervisory.outCommand to Vehicle.inCommand \n\t}\n\n\tEnvConnector def Location {\n\t\tfrom Station.signal to Vehicle.sensor\n\t}\n\n\tEnvConnector def Atach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n\n\tEnvConnector def Detach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n}\n\nEnvironmentConfiguration MyFactoryConfiguration to MyFactory {  \n    \n  Vehicle: agvs;\n  Vehicle.outNotification: agvs.in_outDataAgv.outNotifications;\n  Vehicle.inCommand: agvs.in_outDataAgv.inMoveToStation;\n  Vehicle.sensor: agvs.as.arrivalDetected;\n  Vehicle.arm: agvs.ra.start;\n\n  Supervisory: ss;\n  Supervisory.inNotification: ss.in_outDataS.inNotifications;\n  Supervisory.outCommand: ss.in_outDataS.outMoveToStation;\n    \n  agv1:Vehicle;\n  agv2:Vehicle;\n \n  stationA:Station;    \n  stationA.ID = \"StationA\";\n \n  stationB:Station; \n  stationB.ID = \"StationB\";\n\n  stationC:Station; \n  stationC.ID = \"StationC\";\n\n  stationD:Station; \n  stationD.ID = \"StationD\";\n\n  stationE:Station;\n  stationE.ID = \"StationE\";\n\n  supervisor:Supervisory;      \n\n  part:PartX;\n\n  lane1 : Lane ;\n  lane1.entities.stations = [stationA, stationB, stationC];\n  lane2 : Lane ;\n  lane2.entities.stations = [stationC, stationD, stationE];\n}\n\nEventsDefinitions MyEvents to MyFactoryConfiguration {\n  Event def SupervisoryEvents for supervisor {\n    ON cmdSupervisor \n      THEN cmdAGV2toC {\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); }\n      THEN cmdAGV1toA {\t\t\t\t \n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifLoad\t\t\t\t\t \n      THEN cmdAGV1toC {\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveA\t\t\t\t  \n      THEN cmdAGV1loadA{\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveC\t\t\t\t \n      THEN cmdAGV1UnloadA{\n          supervisor.outCommand.destination=stationA;\n          supervisor.outCommand.armCommand=unload;\n          :Command(supervisor, agv1); }\n    ON AGV1NotifArriveAUnoaded\t\t\t  \n      THEN cmdAGV2loadC{\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv2); }\n    ON AGV2NotifLoad\t\t\t\t \n      THEN cmdAGV2toE {\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); } \t\n    ON AGV2NotifArriveE\t\t\t\t \n      THEN cmdAGV2UnloadE{\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=unload;\n        :Command(supervisor, agv2); }   \n  }\n  Event def AGV1Events for agv1 {\n    ON cmdAGV1toA\n      THEN AGV1NotifTravelA {\n        agv1.outNotification.notification=\"traveling\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationB\t\t\t\t \n      THEN AGV1NotifPassB {\n        agv1.outNotification.notification=\"passed\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationC\t\t\t\t \n      THEN AGV1NotifArriveC {\n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationA\t\t\t\t\t\t\t\t\t\n      THEN AGV1NotifArriveA {\t\t\t\t \n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1atachPartX\t\t\t\t\t \n      THEN AGV1NotifLoad {\n        agv1.outNotification.notification=\"loaded\";\n        :Notify(agv1, supervisor); }\n    ON AGV1detachPartX\t\t\t\t \n      THEN AGV1NotifArriveAUnoaded {\n        agv1.outNotification.notification=\"unloaded\";\n        :Notify(agv1, supervisor); } \n\tON AGV1atStationA\n      THEN AGV1DetectedStationA {\n      \tagv1.sensor = stationA; }\t\n  }\n  Event def AGV2Events for agv2 {\n    ON cmdAGV2toC\t\t\t\t\t \n      THEN AGV2NotifTravelC {\n        agv2.outNotification.notification=\"traveling\";\n        :Notify(agv2, supervisor); }    \n    ON AGV2locationStationC\t\t\t\t\n      THEN AGV2NotifArriveC {\t\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atachPartX\n      THEN AGV2NotifLoad {\n        agv2.outNotification.notification=\"loaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationD\t\n      THEN AGV2NotifPassD {\n        agv2.outNotification.notification=\"passed\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationE\t\t\t\t \n      THEN AGV2NotifArriveE {\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }   \n    ON AGV2detachPartX\t\t\t\t \n      THEN AGV2NotifArriveAUnoaded {\n        agv2.outNotification.notification=\"unloaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atStationD\n      THEN AGV2DetectedStationD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationAEvents for stationA {\t\t \n    ON agv1.sensor == stationA\n      THEN AGV1locationStationA {\n        agv1.location = stationA.signal; } \n  }\n  Event def StationBEvents for stationB {\n    ON agv1.sensor == stationB\t\n      THEN AGV1locationStationB {\t\t\t \n        agv1.location = stationB.signal; }\n  }\n  Event def StationCEvents for stationC {\t\t \n    ON agv1.sensor == stationC\t\t\t\t\n      THEN AGV1locationStationC {\n        agv1.location = stationC.signal; }\n    ON agv2.sensor == stationC\t\t\t \t\n      THEN AGV2locationStationC {\n        agv2.location = stationC.signal; }\n  }\n  Event def StationDEvents for stationD {\n    ON agv2.sensor == stationD\t\n      THEN AGV2locationStationD {\t\t\t \n        agv2.location = stationD.signal; }\n    // Evento para modificar sensor programaticamente\n    ON SetAGV2SensorStationD\n      THEN UpdateAGV2SensorToD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationEEvents for stationE {\t\t \n    ON agv2.sensor == stationE\t\t\t\t\n      THEN agv2locationStationE {\n        agv2.location = stationE.signal; }\n  }\n  Event def PartXEvents for part {\n    ON cmdAGV1loadA\t\t\t\t\t \n      THEN AGV1atachPartX {\n        :Atach(agv1, part); }\n    ON cmdAGV1UnloadA\t\t\t\t\t \n      THEN AGV1detachPartX {\n        :Detach(agv1, part); }\n    ON cmdAGV2loadC\t\t\t\t\t \n      THEN AGV2atachPartX {\n        :Atach(agv2, part); }\n    ON cmdAGV2UnloadE\t\t\t\t\t \n      THEN AGV2detachPartX {\n        :Detach(agv2, part); }\n  }\n}\n\nSceneDefinitions MyScenes to MyEvents {\n  Scene def SCN_MoveAGV1toA on { \n    pre-condition {\n      agv1.location == stationC.ID;\n      part.location == stationA.ID; }\n    start cmdSupervisor;\n    finish AGV1NotifArriveA;\n    post-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n  }\n  Scene def SCN_MoveAGV2toC on { \n    pre-condition {\n      agv2.location == stationD.ID;\n      part.location == stationA.ID; }\n    start cmdAGV2toC;\n    finish AGV2NotifArriveC;\n    post-condition {\n      agv2.location == stationC.ID; \n      part.location == stationA.ID; }\n  }\n  Scene def SCN_AGV1movePartToC on { \n    pre-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n    start AGV1NotifArriveA;\n    finish AGV1detachPartX;\n    post-condition {\n      agv1.location == stationC.ID; \n      part.location == stationC.ID; }\n  }\n  Scene def SCN_AGV2movePartToE on { \n    pre-condition {\n      agv2.location == stationC.ID;\n      part.location == stationC.ID; }\n    start AGV2NotifArriveC;\n    finish AGV2detachPartX;\n    post-condition {\n      agv2.location == stationE.ID;\n      part.location == stationE.ID; }\n  }\n}\n\nScenarioDefinitions MyScenarios to MyScenes {\n  Scenario def Scenario1 { //Scenario standard\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV1movePartToC;\n    SCN_AGV2movePartToE;\n  }\n  Scenario def Scenario2 { //Failing scenario\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV2movePartToE; //Moving part to E before move it to C\n    SCN_AGV1movePartToC;\n  }\n  Scenario def Scenario3 { //Taking 5 parts from A to C\n     let i: Integer = 1;\n     while (i < 5) {\n       SCN_MoveAGV1toA;\n       SCN_AGV1movePartToC;\n       i++;\n     }\n  }\n  Scenario def Scenario4 { //Executing Scenario1 5 times\n     let i: Integer = 1;\n     while (i < 5) {\n       Scenario1;\n       i++; }\n  }\n}\n\nScenarioExecution to MyScenarios {\n  agv1.location = stationC.ID;\n  agv2.location = stationD.ID;\n  part.location = stationA.ID;\n  \n  // ✅ Exemplo 1: Disparar após scene específica\n  inject AGV2atStationD after SCN_MoveAGV1toA;\n  \n  // ✅ Exemplo 2: Disparar quando condição for atendida  \n  inject SetAGV2SensorStationD when agv1.location == stationA.ID;\n  \n  inject AGV1atStationA after cmdAGV1toA;\n  \n  Scenario1;\n  Scenario2;\n  Scenario3;\n  Scenario4;\n  repeat 5 Scenario1; //Repeat 5 times the Scenario1 execution (like Scenario4)\n} \n\nallocations {\n\tactivity CheckStationAC to CheckStation \n\tactivity ControlArmAC to ControlArm\n\tactivity NotifierArmAC to NotifierArm\n\tactivity NotifierMotorAC to NotifierMotor\n\tactivity StartMovingAC to StartMoving\n\tactivity VehicleTimerAC to VehicleTimer\n\texecutable CompareStationsEX to CompareStationsAN\n\texecutable ControlArmEX to ControlArmAN\n\texecutable NotifierArmEX to NotifierArmAN\n\texecutable NotifyAGVFromMotorEX to NotifyAGVFromMotorAN\n\texecutable NotifySupervisoryFromMotorEX to NotifySupervisoryFromMotorAN \n\texecutable PassedMotorEX to PassedMotorAN\n\texecutable SendCommandEX to SendCommandAN\n\texecutable SendCurrentLocationEX to SendCurrentLocationAN\n\texecutable SendDestinationEX to SendDestinationAN\n\texecutable SendStartMotorEX to SendStartMotorAN\n\texecutable StopMotorEX to StopMotorAN\n\texecutable VehicleTimerEX to VehicleTimerAN\n}"},"start":{"offset":25140,"line":867,"column":29},"end":{"offset":25170,"line":867,"column":59}}}}});
    this.lane2 = this.createEntity('Lane', {"name":"lane2","properties":{"entities":{"type":"ArrayLiteralExpression","elements":["stationC","stationD","stationE"],"location":{"source":{"source":"/Users/tales/desenv/SysAdlWebStudio/tales/v0.5/AGV-completo.sysadl","text":"Model SysADLArchitecture;\npackage SysADL.types {\n\tvalue type Int {\n\t}\n\tvalue type Boolean {\n\t}\n\tvalue type String {\n\t}\n\tvalue type Void {\n\t}\n\tvalue type Real {\n\t}\n\tenum NotificationToSupervisory {\n\t\tdeparted, arrived, passed, traveling\n\t}\n\tenum NotificationFromArm {\n\t\tloaded, unloaded\n\t}\n\tenum CommandToArm {\n\t\tload, unload, idle\n\t}\n\tenum NotificationFromMotor {\n\t\tstarted, stopped\n\t}\n\tenum CommandToMotor {\n\t\tstart, stop\n\t}\n\tdatatype Status {\n\t\tattributes: location : Location;\n\t\tdestination : Location;\n\t\tcommand : CommandToArm;\n\t}\n\tdatatype Location{\n\t\tattributes: location : String;\n\t}\n\tdatatype VehicleData{\n\t\tattributes: destination : Location;\n\t\tcommand : CommandToArm;\n\t}\n}\npackage PortsAGV {\n\timport SysADL.types;\n\tport def inLocation {\n\t\tflow in Location\n\t}\n\tport def outLocation {\n\t\tflow out Location\n\t}\n\tport def inStatus {\n\t\tflow in Status\n\t}\n\tport def outStatus {\n\t\tflow out Status\n\t}\n\tport def inVehicleData {\n\t\tflow in VehicleData\n\t}\n\tport def outVehicleData {\n\t\tflow out VehicleData\n\t}\n\tport def inNotificationFromMotor {\n\t\tflow in NotificationFromMotor\n\t}\n\tport def outNotificationFromMotor {\n\t\tflow out NotificationFromMotor\n\t}\n\tport def inCommandToMotor {\n\t\tflow in CommandToMotor\n\t}\n\tport def outCommandToMotor {\n\t\tflow out CommandToMotor\n\t}\n\tport def inNotificationFromArm {\n\t\tflow in NotificationFromArm\n\t}\n\tport def outNotificationFromArm {\n\t\tflow out NotificationFromArm\n\t}\n\tport def inCommandToArm {\n\t\tflow in CommandToArm\n\t}\n\tport def outCommandToArm {\n\t\tflow out CommandToArm\n\t}\n\tport def inNotificationToSupervisory {\n\t\tflow in NotificationToSupervisory\n\t}\n\tport def outNotificationToSupervisory {\n\t\tflow out NotificationToSupervisory\n\t}\n\tport def IAGVSystem {\n\t\tports: inMoveToStation : inVehicleData {\n\t\t}\n\t\toutNotifications : outNotificationToSupervisory {\n\t\t}\n\t}\n\tport def ISupervisorySystem {\n\t\tports: outMoveToStation : outVehicleData {\n\t\t}\n\t\tinNotifications : inNotificationToSupervisory {\n\t\t}\n\t}\n}\npackage ConnectorsAGV {\n\timport PortsAGV;\n\tconnector def notifySupervisory {\n\t\tparticipants: ~ nsIPT : inNotificationToSupervisory {\n\t\t}\n\t\t~ nsOPT : outNotificationToSupervisory {\n\t\t}\n\t\tflows: NotificationToSupervisory from nsOPT to nsIPT\n\t}\n\tconnector def sendVehicleData {\n\t\tparticipants: ~ vdOPT : outVehicleData {\n\t\t}\n\t\t~ vdIPT : inVehicleData {\n\t\t}\n\t\tflows: VehicleData from vdOPT to vdIPT\n\t}\n\tconnector def notificationMotor {\n\t\tparticipants: ~ nmOPT : outNotificationFromMotor {\n\t\t}\n\t\t~ nmIPT : inNotificationFromMotor {\n\t\t}\n\t\tflows: NotificationFromMotor from nmOPT to nmIPT\n\t}\n\tconnector def commandArm {\n\t\tparticipants: ~ caOPT : outCommandToArm {\n\t\t}\n\t\t~ caIPT : inCommandToArm {\n\t\t}\n\t\tflows: CommandToArm from caOPT to caIPT\n\t}\n\tconnector def notificationArm {\n\t\tparticipants: ~ naIPT : inNotificationFromArm {\n\t\t}\n\t\t~ naOPT : outNotificationFromArm {\n\t\t}\n\t\tflows: NotificationFromArm from naOPT to naIPT\n\t}\n\tconnector def commandMotor {\n\t\tparticipants: ~ cmOPT : outCommandToMotor {\n\t\t}\n\t\t~ cmIPT : inCommandToMotor {\n\t\t}\n\t\tflows:  CommandToMotor from  cmOPT to cmIPT\n\t}\n\tconnector def interactionAGVAndSupervisory {\n\t\tparticipants: ~ iagvs : IAGVSystem {\n\t\t}\n\t\t~ iss : ISupervisorySystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tconnectors:\n\t\t\tnS : notifySupervisory bindings  outNotifications = inNotifications; \n\t\t\tsVD : sendVehicleData bindings outMoveToStation = inMoveToStation;\n\t\t}\n\t}\n\tconnector def locationVehicle {\n\t\tparticipants: ~ lOPT : outLocation {\n\t\t}\n\t\t~ lIPT : inLocation {\n\t\t}\n\t\tflows: Location from lOPT to lIPT\n\t}\n\tconnector def status {\n\t\tparticipants: ~ sOPT : outStatus {\n\t\t}\n\t\t~ sIPT : inStatus {\n\t\t}\n\t\tflows: Status from sOPT to sIPT\n\t}\n}\npackage ComponentsAGV {\n\timport PortsAGV;\n\timport ConnectorsAGV;\n\timport SysADL.types;\n\tcomponent def FactoryAutomationSystem {\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tss : SupervisorySystem {\n\t\t\t\tusing ports: in_outDataS : ISupervisorySystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tagvs : AGVSystem [ 1, -1 ] {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tin_outDataAgv : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tds : DisplaySystem {\n\t\t\t\tusing ports: receiveStatus : inStatus {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdataExchange : interactionAGVAndSupervisory bindings in_outDataS = in_outDataAgv;\n\t\t\tupdateStatus : status bindings sendStatus = receiveStatus;\n\t\t}\n\t}\n\tboundary component def DisplaySystem {\n\t\tports: receiveStatus : inStatus {\n\t\t}\n\t}\n\tboundary component def SupervisorySystem {\n\t\tports: in_outData : ISupervisorySystem {\n\t\t}\n\t}\n\tcomponent def AGVSystem {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tm : Motor {\n\t\t\t\tusing ports: start_stop_in : inCommandToMotor {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_out : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tas : ArrivalSensor {\n\t\t\t\tusing ports: arrivalDetected_out : outLocation {\n\t\t\t\t}\n\t\t\t}\n\t\t\tra : RobotArm {\n\t\t\t\tusing ports: start : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tstarted : outNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvc : VehicleControl {\n\t\t\t\tusing ports: sendStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tarrivalDetected_in : inLocation {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tstartedArm : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t\tstarted_stopped_in : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstart_stop_out : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tin_outData : IAGVSystem {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tarrived : locationVehicle bindings arrivalDetected_out = arrivalDetected_in; \n\t\t\tackArm : notificationArm bindings started = startedArm; \n\t\t\tcmdArm : commandArm bindings startArm = start;\n\t\t\tackMotor : notificationMotor bindings started_stopped_out = started_stopped_in;\n\t\t\tcmdMotor : commandMotor bindings  start_stop_out = start_stop_in;\n\t\t\tdelegations:\n\t\t\t sendStatus to sendStatus \n\t\t\tin_outData to in_outData\n\t\t}\n\t}\n\tboundary component def RobotArm {\n\t\tports: start : inCommandToArm {\n\t\t}\n\t\tstarted : outNotificationFromArm {\n\t\t}\n\t}\n\tboundary component def Motor {\n\t\tports: start_stop : inCommandToMotor {\n\t\t}\n\t\tstarted_stopped : outNotificationFromMotor {\n\t\t}\n\t}\n\tboundary component def ArrivalSensor {\n\t\tports: arrivalDetected : outLocation {\n\t\t}\n\t}\n\tcomponent def VehicleControl {\n\t\tports: sendStatus : outStatus {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t\tstartedArm : inNotificationFromArm {\n\t\t}\n\t\tstarted_stopped : inNotificationFromMotor {\n\t\t}\n\t\tstart_stop : outCommandToMotor {\n\t\t}\n\t\tin_outData : IAGVSystem {\n\t\t}\n\t\tconfiguration {\n\t\t\tcomponents:\n\t\t\tcs : CheckStation {\n\t\t\t\tusing ports: ack_cs : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tlocation_cs : outLocation {\n\t\t\t\t}\n\t\t\t\tdestination_cs : inLocation {\n\t\t\t\t}\n\t\t\t\tstop : outCommandToMotor {\n\t\t\t\t}\n\t\t\t\tarrivalDetected : inLocation {\n\t\t\t\t}\n\t\t\t\tpassed : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t}\n\t\t\tca : ControlArm {\n\t\t\t\tusing ports: cmd_ca : inCommandToArm {\n\t\t\t\t}\n\t\t\t\tack_ca : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tstartArm : outCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tnm : NotifierMotor {\n\t\t\t\tusing ports: inAck : inNotificationFromMotor {\n\t\t\t\t}\n\t\t\t\tack : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\toutAck : outNotificationFromMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tsm : StartMoving {\n\t\t\t\tusing ports: move : inVehicleData {\n\t\t\t\t}\n\t\t\t\tcmd_sm : outCommandToArm {\n\t\t\t\t}\n\t\t\t\tdestination : outLocation {\n\t\t\t\t}\n\t\t\t\tstart : outCommandToMotor {\n\t\t\t\t}\n\t\t\t}\n\t\t\tna : NotifierArm {\n\t\t\t\tusing ports: arrivedStatus : outNotificationToSupervisory {\n\t\t\t\t}\n\t\t\t\tloaded_unloaded : inNotificationFromArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tvt : VehicleTimer {\n\t\t\t\tusing ports: AGVStatus : outStatus {\n\t\t\t\t}\n\t\t\t\tlocation_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tdestination_vt : inLocation {\n\t\t\t\t}\n\t\t\t\tcmd : inCommandToArm {\n\t\t\t\t}\n\t\t\t}\n\t\t\tconnectors:\n\t\t\tdestinationStation2 : locationVehicle bindings destination = destination_vt; \n\t\t\tdestinationStation : locationVehicle bindings destination = destination_cs;\n\t\t\tcommand : commandArm bindings cmd_sm = cmd;\n\t\t\tcommand2 : commandArm bindings cmd_sm = cmd_ca;\n\t\t\tcurrentLocation : locationVehicle bindings location_cs = location_vt;\n\t\t\tsendNotificationMotor : notificationMotor bindings outAck = ack_ca;\n\t\t\tsendNotificationMotor2 : notificationMotor bindings outAck = ack_cs;\n\t\t\tdelegations:\n\t\t\tack to outNotifications\n\t\t\tarrivedStatus to outNotifications\n\t\t\tmove to inMoveToStation\n\t\t\tpassed to outNotifications\n\t\t\tloaded_unloaded to startedArm\n\t\t\tinAck to started_stopped\n\t\t\tstartArm to startArm \n\t\t\tAGVStatus to sendStatus \n\t\t\tstart to start_stop \n\t\t\tstop to start_stop \n\t\t\tarrivalDetected to arrivalDetected \n\t\t}\n\t}\n\tcomponent def VehicleTimer {\n\t\tports: AGVStatus : outStatus {\n\t\t}\n\t\tlocation : inLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tcmd : inCommandToArm {\n\t\t}\n\t}\n\tcomponent def NotifierArm {\n\t\tports: arrivedStatus : outNotificationToSupervisory {\n\t\t}\n\t\tloaded_unloaded : inNotificationFromArm {\n\t\t}\n\t}\n\tcomponent def ControlArm {\n\t\tports: cmd : inCommandToArm {\n\t\t}\n\t\tack : inNotificationFromMotor {\n\t\t}\n\t\tstartArm : outCommandToArm {\n\t\t}\n\t}\n\tcomponent def CheckStation {\n\t\tports: ack : inNotificationFromMotor {\n\t\t}\n\t\tlocation : outLocation {\n\t\t}\n\t\tdestination : inLocation {\n\t\t}\n\t\tstop : outCommandToMotor {\n\t\t}\n\t\tarrivalDetected : inLocation {\n\t\t}\n\t\tpassed : outNotificationToSupervisory {\n\t\t}\n\t}\n\tcomponent def NotifierMotor {\n\t\tports: inAck : inNotificationFromMotor {\n\t\t}\n\t\tack : outNotificationToSupervisory {\n\t\t}\n\t\toutAck : outNotificationFromMotor {\n\t\t}\n\t}\n\tcomponent def StartMoving {\n\t\tports: move : inVehicleData {\n\t\t}\n\t\tcmd : outCommandToArm {\n\t\t}\n\t\tdestination : outLocation {\n\t\t}\n\t\tstart : outCommandToMotor {\n\t\t}\n\t}\nactivity def StartMovingAC ( move : VehicleData) : (cmd : CommandToArm, destination : Location, start : CommandToMotor) {\n\t\tbody {\n\t\tactions : sc : SendCommandAN {\n\t\t\t\tusing pins: moveSC : VehicleData;\n\t\t\t}\n\t\t\tsd : SendDestinationAN {\n\t\t\t\tusing pins: moveSD : VehicleData;\n\t\t\t}\n\t\t\tssm : SendStartMotorAN {\n\t\t\t\tusing pins: moveSSM : VehicleData;\n\t\t\t}\n\t\t\tdelegate destination to sc \n\t\t\tdelegate cmd to sd \n\t\t\tdelegate start to ssm\n\t\t\tdelegate move to moveSD \n\t\t\tdelegate move to moveSC \n\t\t\tdelegate move to moveSSM\n\t\t}\n\t}\naction def SendStartMotorAN ( move : VehicleData ) : CommandToMotor {\n\tconstraint : post-condition SendStartMotorEQ\n\t\tdelegate SendStartMotorAN to cmd\n\t}\n\taction def SendCommandAN ( move : VehicleData ) : CommandToArm {\n\tconstraint : post-condition SendCommandEQ\n\tdelegate SendCommandAN to cmd delegate move to move\n\t}\n\taction def SendDestinationAN ( move : VehicleData ) : Location {\n\tconstraint : post-condition SendDestinationEQ\n\tdelegate SendDestinationAN to destination delegate move to move\n\t}\n\tactivity def NotifierMotorAC ( inStatusMotor : NotificationFromMotor ) : (outStatusMotor : NotificationFromMotor, ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : nagvm : NotifyAGVFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tnsm : NotifySupervisoryFromMotorAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate outStatusMotor to nagvm delegate ack to nsm delegate inStatusMotor\n\t\t\tto statusMotor delegate inStatusMotor to statusMotor\n\t\t}\n\t}\n\taction def NotifyAGVFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationFromMotor {\n\tconstraint : post-condition NotifyAGVFromMotorEQ\n\tdelegate NotifyAGVFromMotorAN to outStatusMotor delegate\n\t\tstatusMotor to inStatusMotor\n\t}\n\taction def NotifySupervisoryFromMotorAN ( statusMotor : NotificationFromMotor ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifySupervisoryFromMotorEQ\n\tdelegate NotifySupervisoryFromMotorAN to ack\n\t\tdelegate statusMotor to statusMotor\n\t}\n\tactivity def CheckStationAC ( statusMotor : NotificationFromMotor ) ( destination : Location ) ( inLocation : Location ) : (stopMotor :\n\tCommandToMotor, outLocation : Location, passed : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : cs : CompareStationsAN {\n\t\t\t\tusing pins: statusMotor : NotificationFromMotor; \n\t\t\t\tdestination : Location; location : Location;\n\t\t\t}\n\t\t\tscl : SendCurrentLocationAN {\n\t\t\t\tusing pins: location : Location;\n\t\t\t}\n\t\t\tsm : StopMotorAN {\n\t\t\t\tusing pins: comparisonResultSM : Boolean;\n\t\t\t}\n\t\t\tpm : PassedMotorAN {\n\t\t\t\tusing pins: comparisonResultPM : Boolean;\n\t\t\t}\n\t\t\tdelegate statusMotor to NotificationsMotor \n\t\t\tdelegate destination to\tDestinations \n\t\t\tflow from NotificationsMotor to statusMotor \n\t\t\tflow from Destinations to destination \n\t\t\tdelegate inLocation to location delegate\n\t\t\toutLocation to scl delegate inLocation to location \n\t\t\tdelegate stopMotor to sm \n\t\t\tdelegate passed to pm \n\t\t\tflow from cs to comparisonResultPM\n\t\t\tflow from cs to comparisonResultSM\n\t\t\tdatastore NotificationsMotor : NotificationFromMotor {\n\t\t\t}\n\t\t\tdatastore Destinations : Location {\n\t\t\t}\n\t\t}\n\t}\n\taction def CompareStationsAN ( statusMotor : NotificationFromMotor, destination : Location, location : Location ) : Boolean {\n\tconstraint : post-condition CompareStationsEQ pre-condition NotificationMotorIsStartedEQ\n\tdelegate CompareStationsAN to result delegate location to\n\t\tloc delegate destination to dest\n\t\tdelegate statusMotor to statusMotor\n\t}\n\taction def StopMotorAN ( comparisonResult : Boolean ) : CommandToMotor {\n\tconstraint : post-condition StopMotorEQ\n\tdelegate comparisonResult to result delegate StopMotorAN to cmd\n\t}\n\taction def PassedMotorAN ( comparisonResult : Boolean ) : NotificationToSupervisory {\n\tconstraint : post-condition PassedMotorEQ\n\tdelegate PassedMotorAN to ack delegate comparisonResult to result\n\t}\n\taction def SendCurrentLocationAN ( location : Location ) : Location {\n\tconstraint : post-condition SendCurrentLocationEQ\n\tdelegate location to inLocation delegate\n\t\tSendCurrentLocationAN to outLocation\n\t}\n\tactivity def ControlArmAC ( cmd : CommandToArm ) ( statusMotor : NotificationFromMotor ) : (startArm : CommandToArm) {\n\t\tbody {\n\t\tactions : ca : ControlArmAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tstatusMotor : NotificationFromMotor;\n\t\t\t}\n\t\t\tdelegate startArm to ca delegate cmd to cmd delegate statusMotor to statusMotor\n\t\t}\n\t}\n\tactivity def NotifierArmAC ( statusArm : NotificationFromArm ) :\n\t(ack : NotificationToSupervisory) {\n\t\tbody {\n\t\tactions : na : NotifierArmAN {\n\t\t\t\tusing pins: statusArm : NotificationFromArm;\n\t\t\t}\n\t\t\tdelegate ack to na delegate statusArm to statusArm\n\t\t}\n\t}\n\tactivity def VehicleTimerAC ( destination : Location ) ( location : Location ) ( cmd : CommandToArm ) : (status : Status) {\n\t\tbody {\n\t\tactions : vt : VehicleTimerAN {\n\t\t\t\tusing pins: cmd : CommandToArm;\n\t\t\t\tdestination : Location;\n\t\t\t\tlocation : Location;\n\t\t\t}\n\t\t\tdelegate status to vt delegate cmd to cmd delegate destination to\n\t\t\tdestination delegate location to location\n\t\t}\n\t}\n\taction def ControlArmAN ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) : CommandToArm {\n\tconstraint : post-condition ControlArmEQ\n\tdelegate ControlArmAN to startArm delegate statusMotor to\n\t\tstatusMotor delegate cmd to cmd\n\t}\n\taction def NotifierArmAN ( statusArm : NotificationFromArm ) : NotificationToSupervisory {\n\tconstraint : post-condition NotifierArmEQ\n\tdelegate NotifierArmAN to ack\n\t}\n\taction def VehicleTimerAN ( destination : Location, location : Location, cmd : CommandToArm ) : Status {\n\tconstraint : post-condition VehicleTimerEQ\n\tdelegate VehicleTimerAN to s delegate location to\n\t\tloc delegate destination to dest delegate cmd\n\t\tto cmd\n\t}\n\tconstraint SendStartMotorEQ () : \n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = cmd ==  CommandToMotor::start\n\t\t}\n\tconstraint SendDestinationEQ ( move : VehicleData ) :\n\t\t(destination : Location) {\n\t\t\tequation = destination == move->destination\n\t\t}\n\tconstraint NotifyAGVFromMotorEQ ( inStatusMotor : NotificationFromMotor ) :\n\t\t(outStatusMotor : NotificationFromMotor) {\n\t\t\tequation = outStatusMotor == inStatusMotor\n\t\t}\n\tconstraint SendCommandEQ ( move : VehicleData ) :\n\t\t(cmd : CommandToArm) {\n\t\t\tequation = cmd == move->command\n\t\t}\n\tconstraint NotifySupervisoryFromMotorEQ ( statusMotor : NotificationFromMotor ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started ? \n\t\t\tack == NotificationToSupervisory::departed : \n\t\t\tack == NotificationToSupervisory::traveling\n\t\t}\n\tconstraint NotificationMotorIsStartedEQ (statusMotor : NotificationFromMotor) {\n\t\t\tequation = statusMotor == NotificationFromMotor::started\n\t\t}\n\tconstraint CompareStationsEQ ( dest : Location, loc : Location ) :\n\t\t(result : Boolean) {\n\t\t\tequation = dest == loc ? result == true : result == false\n\t\t}\n\tconstraint StopMotorEQ ( result : Boolean ) :\n\t\t(cmd : CommandToMotor) {\n\t\t\tequation = result == true ? cmd == CommandToMotor::stop : cmd == SysADL.types.Void\n\t\t}\n\tconstraint PassedMotorEQ ( result : Boolean ) :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = result == false ? ack == NotificationToSupervisory::passed : ack == SysADL.types.Void\n\t\t}\n\tconstraint SendCurrentLocationEQ ( inLocation : Location ) :\n\t\t(outLocation : Location) {\n\t\t\tequation = outLocation == inLocation\n\t\t}\n\tconstraint ControlArmEQ ( cmd : CommandToArm, statusMotor : NotificationFromMotor ) :\n\t\t(startArm : CommandToArm) {\n\t\t\tequation = statusMotor == NotificationFromMotor::stopped ?\n\t\t\tstartArm == cmd : startArm == CommandToArm::idle\n\t\t}\n\tconstraint NotifierArmEQ () :\n\t\t(ack : NotificationToSupervisory) {\n\t\t\tequation = ack == NotificationToSupervisory::arrived\n\t\t}\n\tconstraint VehicleTimerEQ ( dest : Location, loc : Location, cmd : CommandToArm ) :\n\t\t(s : Status) {\n\t\t\tequation = s->destination == dest && s->location == loc && s->command == cmd\n\t\t}\n\texecutable def SendStartMotorEX ( in move : VehicleData) : out CommandToMotor {\n\t\treturn CommandToMotor::start;\n\t}\n\texecutable def SendCommandEX ( in move : VehicleData) : out CommandToArm {\n\t\treturn move->command;\n\t}\n\texecutable def SendDestinationEX ( in move : VehicleData) : out Location {\n\t\treturn move->destination;\n\t}\n\texecutable def NotifyAGVFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\tout NotificationFromMotor{\n\t\treturn statusMotor;\n\t}\n\texecutable def NotifySupervisoryFromMotorEX ( in statusMotor : NotificationFromMotor) : \n\t\tout\tNotificationToSupervisory {\n\t\tif (statusMotor == NotificationFromMotor::started) \n\t\t\treturn NotificationToSupervisory::departed;\n\t\telse\n\t\t\treturn NotificationToSupervisory::traveling;\n\t}\n\texecutable def CompareStationsEX ( in destination : Location, in location : Location, \n\t\tin statusMotor : NotificationFromMotor) : \tout Boolean {\n\t\tif(statusMotor == NotificationFromMotor::started && destination == location)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\texecutable def StopMotorEX ( in comparisonResult : Boolean) :\n\tout CommandToMotor {\n\t\tif(comparisonResult == true)\n\t\t\treturn CommandToMotor::stop;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def PassedMotorEX ( in comparisonResult : Boolean) :\n\tout NotificationToSupervisory {\n\t\tif(comparisonResult == false)\n\t\t\treturn NotificationToSupervisory::passed;\n\t\telse\n\t\t\treturn null;\n\t}\n\texecutable def SendCurrentLocationEX ( in location : Location)\n\t: out Location {\n\t\treturn location;\n\t}\n\texecutable def ControlArmEX ( in statusMotor : NotificationFromMotor, in cmd : CommandToArm) : out CommandToArm {\n\t\tif(statusMotor == NotificationFromMotor::stopped)\n\t\t\treturn cmd;\n\t\telse\n\t\t\treturn CommandToArm::idle;\n\t}\n\texecutable def NotifierArmEX ( in statusArm : NotificationFromArm) : \n\tout\tNotificationToSupervisory {\n\t\treturn NotificationToSupervisory::arrived;\n\t}\n\texecutable def VehicleTimerEX ( in location : Location, in cmd : CommandToArm, \n\t\tin destination : Location) : out Status {\n\t\t\n\t\tlet s : Status;\n\t\ts->destination = destination;\n\t\ts->location = location;\n\t\ts->command = cmd;\n\t\t\n\t\treturn s;\n\t}\n}\nRequirement RequestMove ( 1.0 ) {\n\ttext = \"The external Supervisory System sends a \\\"Move\\\" command to the AGV System requesting it to move to a factory station and load/unload a part.\"\n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ReceiveNotifications ( 1.1 ) {\n\ttext = \"The Supervisory System should receive the AGV system notifications.\" \n\tsatisfied by ComponentsAGV.SupervisorySystem;\n}\nRequirement ControlLoadingUnloading ( 2.0 ) {\n\ttext = \"The AGV system must control the loading and unloading of parts between stations factory, interacting with Supervisory and Display Systems.\"\n\tsatisfied by ComponentsAGV.AGVSystem;\n\tRequirement MoveToStation ( 2.1 ) {\n\t\ttext = \"An AGV can move along a track in the factory in a clockwise direction, and start and stop at factory stations.\"\n\t\tRequirement CommandMotorStartMove ( 2.2 ) {\n\t\t\ttext = \"The AGV System sends a \\\"Start Motor\\\" command to Motor to start moving.\"\n\t\t\tsatisfied by ComponentsAGV.StartMoving;\n\t\t}\n\t\tRequirement SendStartedAcknowledgement ( 2.3 ) {\n\t\t\ttext = \"Motor sends \\\"Started\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement DetectArrived ( 2.4 ) {\n\t\t\ttext = \"The arrival sensor must detect that it has arrived at the factory station and notifies the AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.ArrivalSensor;\n\t\t}\n\t\tRequirement CheckDestination ( 2.5 ) {\n\t\t\ttext = \"The AGV System checks if the current station is the arrival station.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement CommandMotorStopMove ( 2.6 ) {\n\t\t\ttext = \"If this station is the destination station, the AGV System sends \\\"Stop Moto\\\" message to Motor, else the vehicle passes the station without stopping.\"\n\t\t\tsatisfied by ComponentsAGV.CheckStation;\n\t\t}\n\t\tRequirement SendStoppedAcknowledgement ( 2.7 ) {\n\t\t\ttext = \"Motor sends \\\"Stopped\\\" acknowledge message to AGV System.\"\n\t\t\tsatisfied by ComponentsAGV.Motor;\n\t\t}\n\t\tRequirement CommandLoadUnload ( 2.8 ) {\n\t\t\ttext = \"The AGV System sends \\\"Load/Unload\\\" message to Robot Arm.\"\n\t\t\tsatisfied by ComponentsAGV.ControlArm;\n\t\t}\n\t\tRequirement SendAcknowledgement ( 2.9 ) {\n\t\t\ttext = \"Robot Arm sends;Load/Unload acknowledge message to AGV System indicating that the arm has finished.\"\n\t\t\tsatisfied by ComponentsAGV.RobotArm;\n\t\t}\n\t\tRequirement NotifySupervisorySystem ( 2.10 ) {\n\t\t\ttext = \"The AGV System must notify the supervisory system when the vehicle start moving or get to a station.\"\n\t\t}\n\t}\n\tRequirement SendVehicleStatus ( 2.13 ) {\n\t\ttext = \"The AGV system should send vehicle status to an external Display System every 30 seconds.\"\n\t\tsatisfied by ComponentsAGV.VehicleTimer;\n\t}\n}\nRequirement NotifyFromMotor ( 2.11 ) {\n\ttext = \"The AGV System must send a \\\"Departed\\\" message to the Supervisory System when vehicle start moving and a \\\"Passed\\\" message when vehicle come to a different station of destination station.\"\n\tsatisfied by ComponentsAGV.NotifierMotor;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement NotifyFromArm ( 2.12 ) {\n\ttext = \"The AGV System must send a \\\"Arrived\\\" message when the part has been loaded/unloaded.\"\n\tsatisfied by ComponentsAGV.NotifierArm;\n\tderive ControlLoadingUnloading.MoveToStation.NotifySupervisorySystem;\n}\nRequirement ReceiveVehicleStatus ( 3.0 ) {\n\ttext = \"The Display System must receive of AGV system the vehicle status.\"\n\tsatisfied by ComponentsAGV.DisplaySystem;\n}\n\n\nEnvironmentDefinition MyFactory {\n\n\tEnvComponent def Station {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t}\n\t\tenvPorts {\n\t\t\tEnvPort def signal \n\t\t}\n\t}\n\n\tEnvComponent def PartX {\n\t\tproperties {\n\t\t\tProperty def ID\n\t\t\tProperty def location\n\t\t}\n\t\tenvPorts {\n\t\t\tEnvPort def surface \n\t\t}\n\t}\n\n\tEnvComponent def Lane {\n\t\tenvComponents {\n\t\t\tstations: Station[],\n\t\t\tvehicles: Vehicle[],\n\t\t\tpartx: PartX\n\t\t}\n\t}\n\n\tEnvComponent def Supervisory {\n\t\tenvPorts {\n\t\t\tEnvPort def inNotification   \n\t\t\tEnvPort def outCommand   \n\t\t}\n\t}\n\n\tEnvComponent def Vehicle {\n\t\tenvPorts {\n\t\t\tEnvPort def outNotification \n\t\t\tEnvPort def inCommand  \n\t\t\tEnvPort def sensor  \t\n\t\t\tEnvPort def arm  \n\t\t}\n\t\tproperties {\n\t\t\tProperty def location\n\t\t}\n\t}\n\n\tEnvConnector def Notify {\n\t\tfrom Vehicle.outNotification to Supervisory.inNotification\n\t}\n\t\n\tEnvConnector def Command {\n\t\tfrom Supervisory.outCommand to Vehicle.inCommand \n\t}\n\n\tEnvConnector def Location {\n\t\tfrom Station.signal to Vehicle.sensor\n\t}\n\n\tEnvConnector def Atach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n\n\tEnvConnector def Detach {\n\t\tfrom Vehicle.arm to PartX.surface\n\t}\n}\n\nEnvironmentConfiguration MyFactoryConfiguration to MyFactory {  \n    \n  Vehicle: agvs;\n  Vehicle.outNotification: agvs.in_outDataAgv.outNotifications;\n  Vehicle.inCommand: agvs.in_outDataAgv.inMoveToStation;\n  Vehicle.sensor: agvs.as.arrivalDetected;\n  Vehicle.arm: agvs.ra.start;\n\n  Supervisory: ss;\n  Supervisory.inNotification: ss.in_outDataS.inNotifications;\n  Supervisory.outCommand: ss.in_outDataS.outMoveToStation;\n    \n  agv1:Vehicle;\n  agv2:Vehicle;\n \n  stationA:Station;    \n  stationA.ID = \"StationA\";\n \n  stationB:Station; \n  stationB.ID = \"StationB\";\n\n  stationC:Station; \n  stationC.ID = \"StationC\";\n\n  stationD:Station; \n  stationD.ID = \"StationD\";\n\n  stationE:Station;\n  stationE.ID = \"StationE\";\n\n  supervisor:Supervisory;      \n\n  part:PartX;\n\n  lane1 : Lane ;\n  lane1.entities.stations = [stationA, stationB, stationC];\n  lane2 : Lane ;\n  lane2.entities.stations = [stationC, stationD, stationE];\n}\n\nEventsDefinitions MyEvents to MyFactoryConfiguration {\n  Event def SupervisoryEvents for supervisor {\n    ON cmdSupervisor \n      THEN cmdAGV2toC {\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); }\n      THEN cmdAGV1toA {\t\t\t\t \n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifLoad\t\t\t\t\t \n      THEN cmdAGV1toC {\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveA\t\t\t\t  \n      THEN cmdAGV1loadA{\n        supervisor.outCommand.destination=stationA;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv1); }\n    ON AGV1NotifArriveC\t\t\t\t \n      THEN cmdAGV1UnloadA{\n          supervisor.outCommand.destination=stationA;\n          supervisor.outCommand.armCommand=unload;\n          :Command(supervisor, agv1); }\n    ON AGV1NotifArriveAUnoaded\t\t\t  \n      THEN cmdAGV2loadC{\n        supervisor.outCommand.destination=stationC;\n        supervisor.outCommand.armCommand=load;\n        :Command(supervisor, agv2); }\n    ON AGV2NotifLoad\t\t\t\t \n      THEN cmdAGV2toE {\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=idle;\n        :Command(supervisor, agv2); } \t\n    ON AGV2NotifArriveE\t\t\t\t \n      THEN cmdAGV2UnloadE{\n        supervisor.outCommand.destination=stationE;\n        supervisor.outCommand.armCommand=unload;\n        :Command(supervisor, agv2); }   \n  }\n  Event def AGV1Events for agv1 {\n    ON cmdAGV1toA\n      THEN AGV1NotifTravelA {\n        agv1.outNotification.notification=\"traveling\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationB\t\t\t\t \n      THEN AGV1NotifPassB {\n        agv1.outNotification.notification=\"passed\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationC\t\t\t\t \n      THEN AGV1NotifArriveC {\n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1locationStationA\t\t\t\t\t\t\t\t\t\n      THEN AGV1NotifArriveA {\t\t\t\t \n        agv1.outNotification.notification=\"arrived\";\n        :Notify(agv1, supervisor); }\n    ON AGV1atachPartX\t\t\t\t\t \n      THEN AGV1NotifLoad {\n        agv1.outNotification.notification=\"loaded\";\n        :Notify(agv1, supervisor); }\n    ON AGV1detachPartX\t\t\t\t \n      THEN AGV1NotifArriveAUnoaded {\n        agv1.outNotification.notification=\"unloaded\";\n        :Notify(agv1, supervisor); } \n\tON AGV1atStationA\n      THEN AGV1DetectedStationA {\n      \tagv1.sensor = stationA; }\t\n  }\n  Event def AGV2Events for agv2 {\n    ON cmdAGV2toC\t\t\t\t\t \n      THEN AGV2NotifTravelC {\n        agv2.outNotification.notification=\"traveling\";\n        :Notify(agv2, supervisor); }    \n    ON AGV2locationStationC\t\t\t\t\n      THEN AGV2NotifArriveC {\t\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atachPartX\n      THEN AGV2NotifLoad {\n        agv2.outNotification.notification=\"loaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationD\t\n      THEN AGV2NotifPassD {\n        agv2.outNotification.notification=\"passed\";\n        :Notify(agv2, supervisor); }\n    ON AGV2locationStationE\t\t\t\t \n      THEN AGV2NotifArriveE {\n        agv2.outNotification.notification=\"arrived\";\n        :Notify(agv2, supervisor); }   \n    ON AGV2detachPartX\t\t\t\t \n      THEN AGV2NotifArriveAUnoaded {\n        agv2.outNotification.notification=\"unloaded\";\n        :Notify(agv2, supervisor); }\n    ON AGV2atStationD\n      THEN AGV2DetectedStationD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationAEvents for stationA {\t\t \n    ON agv1.sensor == stationA\n      THEN AGV1locationStationA {\n        agv1.location = stationA.signal; } \n  }\n  Event def StationBEvents for stationB {\n    ON agv1.sensor == stationB\t\n      THEN AGV1locationStationB {\t\t\t \n        agv1.location = stationB.signal; }\n  }\n  Event def StationCEvents for stationC {\t\t \n    ON agv1.sensor == stationC\t\t\t\t\n      THEN AGV1locationStationC {\n        agv1.location = stationC.signal; }\n    ON agv2.sensor == stationC\t\t\t \t\n      THEN AGV2locationStationC {\n        agv2.location = stationC.signal; }\n  }\n  Event def StationDEvents for stationD {\n    ON agv2.sensor == stationD\t\n      THEN AGV2locationStationD {\t\t\t \n        agv2.location = stationD.signal; }\n    // Evento para modificar sensor programaticamente\n    ON SetAGV2SensorStationD\n      THEN UpdateAGV2SensorToD {\n        agv2.sensor = stationD; }\n  }\n  Event def StationEEvents for stationE {\t\t \n    ON agv2.sensor == stationE\t\t\t\t\n      THEN agv2locationStationE {\n        agv2.location = stationE.signal; }\n  }\n  Event def PartXEvents for part {\n    ON cmdAGV1loadA\t\t\t\t\t \n      THEN AGV1atachPartX {\n        :Atach(agv1, part); }\n    ON cmdAGV1UnloadA\t\t\t\t\t \n      THEN AGV1detachPartX {\n        :Detach(agv1, part); }\n    ON cmdAGV2loadC\t\t\t\t\t \n      THEN AGV2atachPartX {\n        :Atach(agv2, part); }\n    ON cmdAGV2UnloadE\t\t\t\t\t \n      THEN AGV2detachPartX {\n        :Detach(agv2, part); }\n  }\n}\n\nSceneDefinitions MyScenes to MyEvents {\n  Scene def SCN_MoveAGV1toA on { \n    pre-condition {\n      agv1.location == stationC.ID;\n      part.location == stationA.ID; }\n    start cmdSupervisor;\n    finish AGV1NotifArriveA;\n    post-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n  }\n  Scene def SCN_MoveAGV2toC on { \n    pre-condition {\n      agv2.location == stationD.ID;\n      part.location == stationA.ID; }\n    start cmdAGV2toC;\n    finish AGV2NotifArriveC;\n    post-condition {\n      agv2.location == stationC.ID; \n      part.location == stationA.ID; }\n  }\n  Scene def SCN_AGV1movePartToC on { \n    pre-condition {\n      agv1.location == stationA.ID;\n      part.location == stationA.ID; }\n    start AGV1NotifArriveA;\n    finish AGV1detachPartX;\n    post-condition {\n      agv1.location == stationC.ID; \n      part.location == stationC.ID; }\n  }\n  Scene def SCN_AGV2movePartToE on { \n    pre-condition {\n      agv2.location == stationC.ID;\n      part.location == stationC.ID; }\n    start AGV2NotifArriveC;\n    finish AGV2detachPartX;\n    post-condition {\n      agv2.location == stationE.ID;\n      part.location == stationE.ID; }\n  }\n}\n\nScenarioDefinitions MyScenarios to MyScenes {\n  Scenario def Scenario1 { //Scenario standard\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV1movePartToC;\n    SCN_AGV2movePartToE;\n  }\n  Scenario def Scenario2 { //Failing scenario\n    SCN_MoveAGV1toA;\n    SCN_MoveAGV2toC;\n    SCN_AGV2movePartToE; //Moving part to E before move it to C\n    SCN_AGV1movePartToC;\n  }\n  Scenario def Scenario3 { //Taking 5 parts from A to C\n     let i: Integer = 1;\n     while (i < 5) {\n       SCN_MoveAGV1toA;\n       SCN_AGV1movePartToC;\n       i++;\n     }\n  }\n  Scenario def Scenario4 { //Executing Scenario1 5 times\n     let i: Integer = 1;\n     while (i < 5) {\n       Scenario1;\n       i++; }\n  }\n}\n\nScenarioExecution to MyScenarios {\n  agv1.location = stationC.ID;\n  agv2.location = stationD.ID;\n  part.location = stationA.ID;\n  \n  // ✅ Exemplo 1: Disparar após scene específica\n  inject AGV2atStationD after SCN_MoveAGV1toA;\n  \n  // ✅ Exemplo 2: Disparar quando condição for atendida  \n  inject SetAGV2SensorStationD when agv1.location == stationA.ID;\n  \n  inject AGV1atStationA after cmdAGV1toA;\n  \n  Scenario1;\n  Scenario2;\n  Scenario3;\n  Scenario4;\n  repeat 5 Scenario1; //Repeat 5 times the Scenario1 execution (like Scenario4)\n} \n\nallocations {\n\tactivity CheckStationAC to CheckStation \n\tactivity ControlArmAC to ControlArm\n\tactivity NotifierArmAC to NotifierArm\n\tactivity NotifierMotorAC to NotifierMotor\n\tactivity StartMovingAC to StartMoving\n\tactivity VehicleTimerAC to VehicleTimer\n\texecutable CompareStationsEX to CompareStationsAN\n\texecutable ControlArmEX to ControlArmAN\n\texecutable NotifierArmEX to NotifierArmAN\n\texecutable NotifyAGVFromMotorEX to NotifyAGVFromMotorAN\n\texecutable NotifySupervisoryFromMotorEX to NotifySupervisoryFromMotorAN \n\texecutable PassedMotorEX to PassedMotorAN\n\texecutable SendCommandEX to SendCommandAN\n\texecutable SendCurrentLocationEX to SendCurrentLocationAN\n\texecutable SendDestinationEX to SendDestinationAN\n\texecutable SendStartMotorEX to SendStartMotorAN\n\texecutable StopMotorEX to StopMotorAN\n\texecutable VehicleTimerEX to VehicleTimerAN\n}"},"start":{"offset":25217,"line":869,"column":29},"end":{"offset":25247,"line":869,"column":59}}}}});
    
    // Compositions
  }
}

// Events Definitions: MyEvents
class MyEvents extends EventsDefinitions {
  constructor(name = 'MyEvents', opts = {}) {
    super(name, {
      ...opts,
      targetConfiguration: 'MyFactoryConfiguration'
    });

    // Initialize TaskExecutor for hybrid execution
    this.taskExecutor = new TaskExecutor({});

    // SupervisoryEvents Event Definition
    this.SupervisoryEvents = {
      name: 'SupervisoryEvents',
      type: 'rule-based',
      target: 'supervisor',
      rules: [
        {
          trigger: 'cmdSupervisor',
          tasks: {
            cmdAGV2toC: (context) => {
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.performAssignment(context, 'supervisor.outCommand.destination', 'stationC');
              } else {
                supervisor.outCommand.destination = 'stationC';
              }
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.performAssignment(context, 'supervisor.outCommand.armCommand', 'idle');
              } else {
                supervisor.outCommand.armCommand = 'idle';
              }
              // Connection: Command(supervisor, agv2)
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.executeConnection('Command', 'supervisor', 'agv2');
              }
              return true;
            },
            cmdAGV1toA: (context) => {
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.performAssignment(context, 'supervisor.outCommand.destination', 'stationA');
              } else {
                supervisor.outCommand.destination = 'stationA';
              }
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.performAssignment(context, 'supervisor.outCommand.armCommand', 'idle');
              } else {
                supervisor.outCommand.armCommand = 'idle';
              }
              // Connection: Command(supervisor, agv1)
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.executeConnection('Command', 'supervisor', 'agv1');
              }
              return true;
            },
          },
          execute: (context) => {
            if (context.sysadlBase && context.sysadlBase.logger) context.sysadlBase.logger.log('⚡ Executing SupervisoryEvents: cmdSupervisor -> cmdAGV2toC, cmdAGV1toA');
            const results = [];
            const currentRule = this.SupervisoryEvents.rules.find(r => r.trigger === 'cmdSupervisor');
            results.push(currentRule.tasks.cmdAGV2toC(context));
            results.push(currentRule.tasks.cmdAGV1toA(context));
            return results;
          }
        },
        {
          trigger: 'AGV1NotifLoad',
          tasks: {
            cmdAGV1toC: (context) => {
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.performAssignment(context, 'supervisor.outCommand.destination', 'stationA');
              } else {
                supervisor.outCommand.destination = 'stationA';
              }
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.performAssignment(context, 'supervisor.outCommand.armCommand', 'idle');
              } else {
                supervisor.outCommand.armCommand = 'idle';
              }
              // Connection: Command(supervisor, agv1)
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.executeConnection('Command', 'supervisor', 'agv1');
              }
              return true;
            },
          },
          execute: (context) => {
            if (context.sysadlBase && context.sysadlBase.logger) context.sysadlBase.logger.log('⚡ Executing SupervisoryEvents: AGV1NotifLoad -> cmdAGV1toC');
            const results = [];
            const currentRule = this.SupervisoryEvents.rules.find(r => r.trigger === 'AGV1NotifLoad');
            results.push(currentRule.tasks.cmdAGV1toC(context));
            return results;
          }
        },
        {
          trigger: 'AGV1NotifArriveA',
          tasks: {
            cmdAGV1loadA: (context) => {
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.performAssignment(context, 'supervisor.outCommand.destination', 'stationA');
              } else {
                supervisor.outCommand.destination = 'stationA';
              }
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.performAssignment(context, 'supervisor.outCommand.armCommand', 'load');
              } else {
                supervisor.outCommand.armCommand = 'load';
              }
              // Connection: Command(supervisor, agv1)
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.executeConnection('Command', 'supervisor', 'agv1');
              }
              return true;
            },
          },
          execute: (context) => {
            if (context.sysadlBase && context.sysadlBase.logger) context.sysadlBase.logger.log('⚡ Executing SupervisoryEvents: AGV1NotifArriveA -> cmdAGV1loadA');
            const results = [];
            const currentRule = this.SupervisoryEvents.rules.find(r => r.trigger === 'AGV1NotifArriveA');
            results.push(currentRule.tasks.cmdAGV1loadA(context));
            return results;
          }
        },
        {
          trigger: 'AGV1NotifArriveC',
          tasks: {
            cmdAGV1UnloadA: (context) => {
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.performAssignment(context, 'supervisor.outCommand.destination', 'stationA');
              } else {
                supervisor.outCommand.destination = 'stationA';
              }
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.performAssignment(context, 'supervisor.outCommand.armCommand', 'unload');
              } else {
                supervisor.outCommand.armCommand = 'unload';
              }
              // Connection: Command(supervisor, agv1)
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.executeConnection('Command', 'supervisor', 'agv1');
              }
              return true;
            },
          },
          execute: (context) => {
            if (context.sysadlBase && context.sysadlBase.logger) context.sysadlBase.logger.log('⚡ Executing SupervisoryEvents: AGV1NotifArriveC -> cmdAGV1UnloadA');
            const results = [];
            const currentRule = this.SupervisoryEvents.rules.find(r => r.trigger === 'AGV1NotifArriveC');
            results.push(currentRule.tasks.cmdAGV1UnloadA(context));
            return results;
          }
        },
        {
          trigger: 'AGV1NotifArriveAUnoaded',
          tasks: {
            cmdAGV2loadC: (context) => {
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.performAssignment(context, 'supervisor.outCommand.destination', 'stationC');
              } else {
                supervisor.outCommand.destination = 'stationC';
              }
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.performAssignment(context, 'supervisor.outCommand.armCommand', 'load');
              } else {
                supervisor.outCommand.armCommand = 'load';
              }
              // Connection: Command(supervisor, agv2)
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.executeConnection('Command', 'supervisor', 'agv2');
              }
              return true;
            },
          },
          execute: (context) => {
            if (context.sysadlBase && context.sysadlBase.logger) context.sysadlBase.logger.log('⚡ Executing SupervisoryEvents: AGV1NotifArriveAUnoaded -> cmdAGV2loadC');
            const results = [];
            const currentRule = this.SupervisoryEvents.rules.find(r => r.trigger === 'AGV1NotifArriveAUnoaded');
            results.push(currentRule.tasks.cmdAGV2loadC(context));
            return results;
          }
        },
        {
          trigger: 'AGV2NotifLoad',
          tasks: {
            cmdAGV2toE: (context) => {
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.performAssignment(context, 'supervisor.outCommand.destination', 'stationE');
              } else {
                supervisor.outCommand.destination = 'stationE';
              }
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.performAssignment(context, 'supervisor.outCommand.armCommand', 'idle');
              } else {
                supervisor.outCommand.armCommand = 'idle';
              }
              // Connection: Command(supervisor, agv2)
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.executeConnection('Command', 'supervisor', 'agv2');
              }
              return true;
            },
          },
          execute: (context) => {
            if (context.sysadlBase && context.sysadlBase.logger) context.sysadlBase.logger.log('⚡ Executing SupervisoryEvents: AGV2NotifLoad -> cmdAGV2toE');
            const results = [];
            const currentRule = this.SupervisoryEvents.rules.find(r => r.trigger === 'AGV2NotifLoad');
            results.push(currentRule.tasks.cmdAGV2toE(context));
            return results;
          }
        },
        {
          trigger: 'AGV2NotifArriveE',
          tasks: {
            cmdAGV2UnloadE: (context) => {
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.performAssignment(context, 'supervisor.outCommand.destination', 'stationE');
              } else {
                supervisor.outCommand.destination = 'stationE';
              }
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.performAssignment(context, 'supervisor.outCommand.armCommand', 'unload');
              } else {
                supervisor.outCommand.armCommand = 'unload';
              }
              // Connection: Command(supervisor, agv2)
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.executeConnection('Command', 'supervisor', 'agv2');
              }
              return true;
            },
          },
          execute: (context) => {
            if (context.sysadlBase && context.sysadlBase.logger) context.sysadlBase.logger.log('⚡ Executing SupervisoryEvents: AGV2NotifArriveE -> cmdAGV2UnloadE');
            const results = [];
            const currentRule = this.SupervisoryEvents.rules.find(r => r.trigger === 'AGV2NotifArriveE');
            results.push(currentRule.tasks.cmdAGV2UnloadE(context));
            return results;
          }
        },
      ],
      hasRule: (triggerName) => {
        return this.SupervisoryEvents.rules.some(rule => rule.trigger === triggerName);
      },
      executeRule: (triggerName, context) => {
        const rule = this.SupervisoryEvents.rules.find(r => r.trigger === triggerName);
        return rule ? rule.execute(context) : null;
      }
    };

    // AGV1Events Event Definition
    this.AGV1Events = {
      name: 'AGV1Events',
      type: 'rule-based',
      target: 'agv1',
      rules: [
        {
          trigger: 'cmdAGV1toA',
          tasks: {
            AGV1NotifTravelA: (context) => {
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.performAssignment(context, 'agv1.outNotification.notification', "traveling");
              } else {
                agv1.outNotification.notification = "traveling";
              }
              // Connection: Notify(agv1, supervisor)
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.executeConnection('Notify', 'agv1', 'supervisor');
              }
              return true;
            },
          },
          execute: (context) => {
            if (context.sysadlBase && context.sysadlBase.logger) context.sysadlBase.logger.log('⚡ Executing AGV1Events: cmdAGV1toA -> AGV1NotifTravelA');
            const results = [];
            const currentRule = this.AGV1Events.rules.find(r => r.trigger === 'cmdAGV1toA');
            results.push(currentRule.tasks.AGV1NotifTravelA(context));
            return results;
          }
        },
        {
          trigger: 'AGV1locationStationB',
          tasks: {
            AGV1NotifPassB: (context) => {
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.performAssignment(context, 'agv1.outNotification.notification', "passed");
              } else {
                agv1.outNotification.notification = "passed";
              }
              // Connection: Notify(agv1, supervisor)
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.executeConnection('Notify', 'agv1', 'supervisor');
              }
              return true;
            },
          },
          execute: (context) => {
            if (context.sysadlBase && context.sysadlBase.logger) context.sysadlBase.logger.log('⚡ Executing AGV1Events: AGV1locationStationB -> AGV1NotifPassB');
            const results = [];
            const currentRule = this.AGV1Events.rules.find(r => r.trigger === 'AGV1locationStationB');
            results.push(currentRule.tasks.AGV1NotifPassB(context));
            return results;
          }
        },
        {
          trigger: 'AGV1locationStationC',
          tasks: {
            AGV1NotifArriveC: (context) => {
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.performAssignment(context, 'agv1.outNotification.notification', "arrived");
              } else {
                agv1.outNotification.notification = "arrived";
              }
              // Connection: Notify(agv1, supervisor)
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.executeConnection('Notify', 'agv1', 'supervisor');
              }
              return true;
            },
          },
          execute: (context) => {
            if (context.sysadlBase && context.sysadlBase.logger) context.sysadlBase.logger.log('⚡ Executing AGV1Events: AGV1locationStationC -> AGV1NotifArriveC');
            const results = [];
            const currentRule = this.AGV1Events.rules.find(r => r.trigger === 'AGV1locationStationC');
            results.push(currentRule.tasks.AGV1NotifArriveC(context));
            return results;
          }
        },
        {
          trigger: 'AGV1locationStationA',
          tasks: {
            AGV1NotifArriveA: (context) => {
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.performAssignment(context, 'agv1.outNotification.notification', "arrived");
              } else {
                agv1.outNotification.notification = "arrived";
              }
              // Connection: Notify(agv1, supervisor)
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.executeConnection('Notify', 'agv1', 'supervisor');
              }
              return true;
            },
          },
          execute: (context) => {
            if (context.sysadlBase && context.sysadlBase.logger) context.sysadlBase.logger.log('⚡ Executing AGV1Events: AGV1locationStationA -> AGV1NotifArriveA');
            const results = [];
            const currentRule = this.AGV1Events.rules.find(r => r.trigger === 'AGV1locationStationA');
            results.push(currentRule.tasks.AGV1NotifArriveA(context));
            return results;
          }
        },
        {
          trigger: 'AGV1atachPartX',
          tasks: {
            AGV1NotifLoad: (context) => {
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.performAssignment(context, 'agv1.outNotification.notification', "loaded");
              } else {
                agv1.outNotification.notification = "loaded";
              }
              // Connection: Notify(agv1, supervisor)
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.executeConnection('Notify', 'agv1', 'supervisor');
              }
              return true;
            },
          },
          execute: (context) => {
            if (context.sysadlBase && context.sysadlBase.logger) context.sysadlBase.logger.log('⚡ Executing AGV1Events: AGV1atachPartX -> AGV1NotifLoad');
            const results = [];
            const currentRule = this.AGV1Events.rules.find(r => r.trigger === 'AGV1atachPartX');
            results.push(currentRule.tasks.AGV1NotifLoad(context));
            return results;
          }
        },
        {
          trigger: 'AGV1detachPartX',
          tasks: {
            AGV1NotifArriveAUnoaded: (context) => {
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.performAssignment(context, 'agv1.outNotification.notification', "unloaded");
              } else {
                agv1.outNotification.notification = "unloaded";
              }
              // Connection: Notify(agv1, supervisor)
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.executeConnection('Notify', 'agv1', 'supervisor');
              }
              return true;
            },
          },
          execute: (context) => {
            if (context.sysadlBase && context.sysadlBase.logger) context.sysadlBase.logger.log('⚡ Executing AGV1Events: AGV1detachPartX -> AGV1NotifArriveAUnoaded');
            const results = [];
            const currentRule = this.AGV1Events.rules.find(r => r.trigger === 'AGV1detachPartX');
            results.push(currentRule.tasks.AGV1NotifArriveAUnoaded(context));
            return results;
          }
        },
        {
          trigger: 'AGV1atStationA',
          tasks: {
            AGV1DetectedStationA: (context) => {
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.performAssignment(context, 'agv1.sensor', 'stationA');
              } else {
                agv1.sensor = 'stationA';
              }
              return true;
            },
          },
          execute: (context) => {
            if (context.sysadlBase && context.sysadlBase.logger) context.sysadlBase.logger.log('⚡ Executing AGV1Events: AGV1atStationA -> AGV1DetectedStationA');
            const results = [];
            const currentRule = this.AGV1Events.rules.find(r => r.trigger === 'AGV1atStationA');
            results.push(currentRule.tasks.AGV1DetectedStationA(context));
            return results;
          }
        },
      ],
      hasRule: (triggerName) => {
        return this.AGV1Events.rules.some(rule => rule.trigger === triggerName);
      },
      executeRule: (triggerName, context) => {
        const rule = this.AGV1Events.rules.find(r => r.trigger === triggerName);
        return rule ? rule.execute(context) : null;
      }
    };

    // AGV2Events Event Definition
    this.AGV2Events = {
      name: 'AGV2Events',
      type: 'rule-based',
      target: 'agv2',
      rules: [
        {
          trigger: 'cmdAGV2toC',
          tasks: {
            AGV2NotifTravelC: (context) => {
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.performAssignment(context, 'agv2.outNotification.notification', "traveling");
              } else {
                agv2.outNotification.notification = "traveling";
              }
              // Connection: Notify(agv2, supervisor)
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.executeConnection('Notify', 'agv2', 'supervisor');
              }
              return true;
            },
          },
          execute: (context) => {
            if (context.sysadlBase && context.sysadlBase.logger) context.sysadlBase.logger.log('⚡ Executing AGV2Events: cmdAGV2toC -> AGV2NotifTravelC');
            const results = [];
            const currentRule = this.AGV2Events.rules.find(r => r.trigger === 'cmdAGV2toC');
            results.push(currentRule.tasks.AGV2NotifTravelC(context));
            return results;
          }
        },
        {
          trigger: 'AGV2locationStationC',
          tasks: {
            AGV2NotifArriveC: (context) => {
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.performAssignment(context, 'agv2.outNotification.notification', "arrived");
              } else {
                agv2.outNotification.notification = "arrived";
              }
              // Connection: Notify(agv2, supervisor)
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.executeConnection('Notify', 'agv2', 'supervisor');
              }
              return true;
            },
          },
          execute: (context) => {
            if (context.sysadlBase && context.sysadlBase.logger) context.sysadlBase.logger.log('⚡ Executing AGV2Events: AGV2locationStationC -> AGV2NotifArriveC');
            const results = [];
            const currentRule = this.AGV2Events.rules.find(r => r.trigger === 'AGV2locationStationC');
            results.push(currentRule.tasks.AGV2NotifArriveC(context));
            return results;
          }
        },
        {
          trigger: 'AGV2atachPartX',
          tasks: {
            AGV2NotifLoad: (context) => {
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.performAssignment(context, 'agv2.outNotification.notification', "loaded");
              } else {
                agv2.outNotification.notification = "loaded";
              }
              // Connection: Notify(agv2, supervisor)
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.executeConnection('Notify', 'agv2', 'supervisor');
              }
              return true;
            },
          },
          execute: (context) => {
            if (context.sysadlBase && context.sysadlBase.logger) context.sysadlBase.logger.log('⚡ Executing AGV2Events: AGV2atachPartX -> AGV2NotifLoad');
            const results = [];
            const currentRule = this.AGV2Events.rules.find(r => r.trigger === 'AGV2atachPartX');
            results.push(currentRule.tasks.AGV2NotifLoad(context));
            return results;
          }
        },
        {
          trigger: 'AGV2locationStationD',
          tasks: {
            AGV2NotifPassD: (context) => {
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.performAssignment(context, 'agv2.outNotification.notification', "passed");
              } else {
                agv2.outNotification.notification = "passed";
              }
              // Connection: Notify(agv2, supervisor)
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.executeConnection('Notify', 'agv2', 'supervisor');
              }
              return true;
            },
          },
          execute: (context) => {
            if (context.sysadlBase && context.sysadlBase.logger) context.sysadlBase.logger.log('⚡ Executing AGV2Events: AGV2locationStationD -> AGV2NotifPassD');
            const results = [];
            const currentRule = this.AGV2Events.rules.find(r => r.trigger === 'AGV2locationStationD');
            results.push(currentRule.tasks.AGV2NotifPassD(context));
            return results;
          }
        },
        {
          trigger: 'AGV2locationStationE',
          tasks: {
            AGV2NotifArriveE: (context) => {
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.performAssignment(context, 'agv2.outNotification.notification', "arrived");
              } else {
                agv2.outNotification.notification = "arrived";
              }
              // Connection: Notify(agv2, supervisor)
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.executeConnection('Notify', 'agv2', 'supervisor');
              }
              return true;
            },
          },
          execute: (context) => {
            if (context.sysadlBase && context.sysadlBase.logger) context.sysadlBase.logger.log('⚡ Executing AGV2Events: AGV2locationStationE -> AGV2NotifArriveE');
            const results = [];
            const currentRule = this.AGV2Events.rules.find(r => r.trigger === 'AGV2locationStationE');
            results.push(currentRule.tasks.AGV2NotifArriveE(context));
            return results;
          }
        },
        {
          trigger: 'AGV2detachPartX',
          tasks: {
            AGV2NotifArriveAUnoaded: (context) => {
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.performAssignment(context, 'agv2.outNotification.notification', "unloaded");
              } else {
                agv2.outNotification.notification = "unloaded";
              }
              // Connection: Notify(agv2, supervisor)
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.executeConnection('Notify', 'agv2', 'supervisor');
              }
              return true;
            },
          },
          execute: (context) => {
            if (context.sysadlBase && context.sysadlBase.logger) context.sysadlBase.logger.log('⚡ Executing AGV2Events: AGV2detachPartX -> AGV2NotifArriveAUnoaded');
            const results = [];
            const currentRule = this.AGV2Events.rules.find(r => r.trigger === 'AGV2detachPartX');
            results.push(currentRule.tasks.AGV2NotifArriveAUnoaded(context));
            return results;
          }
        },
        {
          trigger: 'AGV2atStationD',
          tasks: {
            AGV2DetectedStationD: (context) => {
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.performAssignment(context, 'agv2.sensor', 'stationD');
              } else {
                agv2.sensor = 'stationD';
              }
              return true;
            },
          },
          execute: (context) => {
            if (context.sysadlBase && context.sysadlBase.logger) context.sysadlBase.logger.log('⚡ Executing AGV2Events: AGV2atStationD -> AGV2DetectedStationD');
            const results = [];
            const currentRule = this.AGV2Events.rules.find(r => r.trigger === 'AGV2atStationD');
            results.push(currentRule.tasks.AGV2DetectedStationD(context));
            return results;
          }
        },
      ],
      hasRule: (triggerName) => {
        return this.AGV2Events.rules.some(rule => rule.trigger === triggerName);
      },
      executeRule: (triggerName, context) => {
        const rule = this.AGV2Events.rules.find(r => r.trigger === triggerName);
        return rule ? rule.execute(context) : null;
      }
    };

    // StationAEvents Event Definition
    this.StationAEvents = {
      name: 'StationAEvents',
      type: 'rule-based',
      target: 'stationA',
      rules: [
        {
          trigger: 'agv1.sensor',
          tasks: {
            AGV1locationStationA: (context) => {
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.performAssignment(context, 'agv1.location', 'stationA.signal');
              } else {
                agv1.location = 'stationA.signal';
              }
              return true;
            },
          },
          execute: (context) => {
            if (context.sysadlBase && context.sysadlBase.logger) context.sysadlBase.logger.log('⚡ Executing StationAEvents: agv1.sensor -> AGV1locationStationA');
            const results = [];
            const currentRule = this.StationAEvents.rules.find(r => r.trigger === 'agv1.sensor');
            results.push(currentRule.tasks.AGV1locationStationA(context));
            return results;
          }
        },
      ],
      hasRule: (triggerName) => {
        return this.StationAEvents.rules.some(rule => rule.trigger === triggerName);
      },
      executeRule: (triggerName, context) => {
        const rule = this.StationAEvents.rules.find(r => r.trigger === triggerName);
        return rule ? rule.execute(context) : null;
      }
    };

    // StationBEvents Event Definition
    this.StationBEvents = {
      name: 'StationBEvents',
      type: 'rule-based',
      target: 'stationB',
      rules: [
        {
          trigger: 'agv1.sensor',
          tasks: {
            AGV1locationStationB: (context) => {
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.performAssignment(context, 'agv1.location', 'stationB.signal');
              } else {
                agv1.location = 'stationB.signal';
              }
              return true;
            },
          },
          execute: (context) => {
            if (context.sysadlBase && context.sysadlBase.logger) context.sysadlBase.logger.log('⚡ Executing StationBEvents: agv1.sensor -> AGV1locationStationB');
            const results = [];
            const currentRule = this.StationBEvents.rules.find(r => r.trigger === 'agv1.sensor');
            results.push(currentRule.tasks.AGV1locationStationB(context));
            return results;
          }
        },
      ],
      hasRule: (triggerName) => {
        return this.StationBEvents.rules.some(rule => rule.trigger === triggerName);
      },
      executeRule: (triggerName, context) => {
        const rule = this.StationBEvents.rules.find(r => r.trigger === triggerName);
        return rule ? rule.execute(context) : null;
      }
    };

    // StationCEvents Event Definition
    this.StationCEvents = {
      name: 'StationCEvents',
      type: 'rule-based',
      target: 'stationC',
      rules: [
        {
          trigger: 'agv1.sensor',
          tasks: {
            AGV1locationStationC: (context) => {
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.performAssignment(context, 'agv1.location', 'stationC.signal');
              } else {
                agv1.location = 'stationC.signal';
              }
              return true;
            },
          },
          execute: (context) => {
            if (context.sysadlBase && context.sysadlBase.logger) context.sysadlBase.logger.log('⚡ Executing StationCEvents: agv1.sensor -> AGV1locationStationC');
            const results = [];
            const currentRule = this.StationCEvents.rules.find(r => r.trigger === 'agv1.sensor');
            results.push(currentRule.tasks.AGV1locationStationC(context));
            return results;
          }
        },
        {
          trigger: 'agv2.sensor',
          tasks: {
            AGV2locationStationC: (context) => {
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.performAssignment(context, 'agv2.location', 'stationC.signal');
              } else {
                agv2.location = 'stationC.signal';
              }
              return true;
            },
          },
          execute: (context) => {
            if (context.sysadlBase && context.sysadlBase.logger) context.sysadlBase.logger.log('⚡ Executing StationCEvents: agv2.sensor -> AGV2locationStationC');
            const results = [];
            const currentRule = this.StationCEvents.rules.find(r => r.trigger === 'agv2.sensor');
            results.push(currentRule.tasks.AGV2locationStationC(context));
            return results;
          }
        },
      ],
      hasRule: (triggerName) => {
        return this.StationCEvents.rules.some(rule => rule.trigger === triggerName);
      },
      executeRule: (triggerName, context) => {
        const rule = this.StationCEvents.rules.find(r => r.trigger === triggerName);
        return rule ? rule.execute(context) : null;
      }
    };

    // StationDEvents Event Definition
    this.StationDEvents = {
      name: 'StationDEvents',
      type: 'rule-based',
      target: 'stationD',
      rules: [
        {
          trigger: 'agv2.sensor',
          tasks: {
            AGV2locationStationD: (context) => {
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.performAssignment(context, 'agv2.location', 'stationD.signal');
              } else {
                agv2.location = 'stationD.signal';
              }
              return true;
            },
          },
          execute: (context) => {
            if (context.sysadlBase && context.sysadlBase.logger) context.sysadlBase.logger.log('⚡ Executing StationDEvents: agv2.sensor -> AGV2locationStationD');
            const results = [];
            const currentRule = this.StationDEvents.rules.find(r => r.trigger === 'agv2.sensor');
            results.push(currentRule.tasks.AGV2locationStationD(context));
            return results;
          }
        },
        {
          trigger: 'SetAGV2SensorStationD',
          tasks: {
            UpdateAGV2SensorToD: (context) => {
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.performAssignment(context, 'agv2.sensor', 'stationD');
              } else {
                agv2.sensor = 'stationD';
              }
              return true;
            },
          },
          execute: (context) => {
            if (context.sysadlBase && context.sysadlBase.logger) context.sysadlBase.logger.log('⚡ Executing StationDEvents: SetAGV2SensorStationD -> UpdateAGV2SensorToD');
            const results = [];
            const currentRule = this.StationDEvents.rules.find(r => r.trigger === 'SetAGV2SensorStationD');
            results.push(currentRule.tasks.UpdateAGV2SensorToD(context));
            return results;
          }
        },
      ],
      hasRule: (triggerName) => {
        return this.StationDEvents.rules.some(rule => rule.trigger === triggerName);
      },
      executeRule: (triggerName, context) => {
        const rule = this.StationDEvents.rules.find(r => r.trigger === triggerName);
        return rule ? rule.execute(context) : null;
      }
    };

    // StationEEvents Event Definition
    this.StationEEvents = {
      name: 'StationEEvents',
      type: 'rule-based',
      target: 'stationE',
      rules: [
        {
          trigger: 'agv2.sensor',
          tasks: {
            agv2locationStationE: (context) => {
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.performAssignment(context, 'agv2.location', 'stationE.signal');
              } else {
                agv2.location = 'stationE.signal';
              }
              return true;
            },
          },
          execute: (context) => {
            if (context.sysadlBase && context.sysadlBase.logger) context.sysadlBase.logger.log('⚡ Executing StationEEvents: agv2.sensor -> agv2locationStationE');
            const results = [];
            const currentRule = this.StationEEvents.rules.find(r => r.trigger === 'agv2.sensor');
            results.push(currentRule.tasks.agv2locationStationE(context));
            return results;
          }
        },
      ],
      hasRule: (triggerName) => {
        return this.StationEEvents.rules.some(rule => rule.trigger === triggerName);
      },
      executeRule: (triggerName, context) => {
        const rule = this.StationEEvents.rules.find(r => r.trigger === triggerName);
        return rule ? rule.execute(context) : null;
      }
    };

    // PartXEvents Event Definition
    this.PartXEvents = {
      name: 'PartXEvents',
      type: 'rule-based',
      target: 'part',
      rules: [
        {
          trigger: 'cmdAGV1loadA',
          tasks: {
            AGV1atachPartX: (context) => {
              // Connection: Atach(agv1, part)
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.executeConnection('Atach', 'agv1', 'part');
              }
              return true;
            },
          },
          execute: (context) => {
            if (context.sysadlBase && context.sysadlBase.logger) context.sysadlBase.logger.log('⚡ Executing PartXEvents: cmdAGV1loadA -> AGV1atachPartX');
            const results = [];
            const currentRule = this.PartXEvents.rules.find(r => r.trigger === 'cmdAGV1loadA');
            results.push(currentRule.tasks.AGV1atachPartX(context));
            return results;
          }
        },
        {
          trigger: 'cmdAGV1UnloadA',
          tasks: {
            AGV1detachPartX: (context) => {
              // Connection: Detach(agv1, part)
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.executeConnection('Detach', 'agv1', 'part');
              }
              return true;
            },
          },
          execute: (context) => {
            if (context.sysadlBase && context.sysadlBase.logger) context.sysadlBase.logger.log('⚡ Executing PartXEvents: cmdAGV1UnloadA -> AGV1detachPartX');
            const results = [];
            const currentRule = this.PartXEvents.rules.find(r => r.trigger === 'cmdAGV1UnloadA');
            results.push(currentRule.tasks.AGV1detachPartX(context));
            return results;
          }
        },
        {
          trigger: 'cmdAGV2loadC',
          tasks: {
            AGV2atachPartX: (context) => {
              // Connection: Atach(agv2, part)
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.executeConnection('Atach', 'agv2', 'part');
              }
              return true;
            },
          },
          execute: (context) => {
            if (context.sysadlBase && context.sysadlBase.logger) context.sysadlBase.logger.log('⚡ Executing PartXEvents: cmdAGV2loadC -> AGV2atachPartX');
            const results = [];
            const currentRule = this.PartXEvents.rules.find(r => r.trigger === 'cmdAGV2loadC');
            results.push(currentRule.tasks.AGV2atachPartX(context));
            return results;
          }
        },
        {
          trigger: 'cmdAGV2UnloadE',
          tasks: {
            AGV2detachPartX: (context) => {
              // Connection: Detach(agv2, part)
              if (context.sysadlBase && context.sysadlBase.helpers) {
                context.sysadlBase.helpers.executeConnection('Detach', 'agv2', 'part');
              }
              return true;
            },
          },
          execute: (context) => {
            if (context.sysadlBase && context.sysadlBase.logger) context.sysadlBase.logger.log('⚡ Executing PartXEvents: cmdAGV2UnloadE -> AGV2detachPartX');
            const results = [];
            const currentRule = this.PartXEvents.rules.find(r => r.trigger === 'cmdAGV2UnloadE');
            results.push(currentRule.tasks.AGV2detachPartX(context));
            return results;
          }
        },
      ],
      hasRule: (triggerName) => {
        return this.PartXEvents.rules.some(rule => rule.trigger === triggerName);
      },
      executeRule: (triggerName, context) => {
        const rule = this.PartXEvents.rules.find(r => r.trigger === triggerName);
        return rule ? rule.execute(context) : null;
      }
    };

  }

}

// Enhanced Scene: SCN_MoveAGV1toA
class SCN_MoveAGV1toA extends Scene {
  constructor(name = 'SCN_MoveAGV1toA', opts = {}) {
    super(name, {
      ...opts,
      sceneType: 'scene',
      startEvent: 'cmdSupervisor',
      finishEvent: 'AGV1NotifArriveA',
      entities: [],
      initialStates: {}
    });
  }

  
  validatePreConditions(context) {
    // Enhanced pre-condition validation with context support
    if (!context) {
      throw new Error('Context is required for pre-condition evaluation');
    }

    try {
      // Condition 1: agv1.location == stationC.ID
      const agv1Entity = this.getEntity(context, 'agv1');
      console.log('DEBUG: agv1Entity:', agv1Entity);
      if (!agv1Entity) {
        throw new Error('Entity agv1 not found in context');
      }
      const stationCEntity = this.getEntity(context, 'stationC');
      if (!stationCEntity) {
        throw new Error('Entity stationC not found in context');
      }
      console.log('DEBUG: Comparing agv1.location (' + agv1Entity.properties.location + ') with stationC.ID (' + stationCEntity.properties.ID + ')');
      const condition1 = this.compareValues(agv1Entity.properties.location, stationCEntity.properties.ID);
      // Condition 2: part.location == stationA.ID
      const partEntity = this.getEntity(context, 'part');
      console.log('DEBUG: partEntity:', partEntity);
      if (!partEntity) {
        throw new Error('Entity part not found in context');
      }
      const stationAEntity = this.getEntity(context, 'stationA');
      if (!stationAEntity) {
        throw new Error('Entity stationA not found in context');
      }
      console.log('DEBUG: Comparing part.location (' + partEntity.properties.location + ') with stationA.ID (' + stationAEntity.properties.ID + ')');
      const condition2 = this.compareValues(partEntity.properties.location, stationAEntity.properties.ID);

      // All conditions must be satisfied
      const allConditionsMet = condition1 && condition2;
      return allConditionsMet;
    } catch (error) {
      console.error(`Error evaluating pre-conditions for ${this.name}:`, error.message);
      return false;
    }
  }

  
  validatePostConditions(context) {
    // Enhanced post-condition validation with context support
    if (!context) {
      throw new Error('Context is required for post-condition evaluation');
    }

    try {
      // Condition 1: agv1.location == stationA.ID
      const agv1Entity = this.getEntity(context, 'agv1');
      console.log('DEBUG: agv1Entity:', agv1Entity);
      if (!agv1Entity) {
        throw new Error('Entity agv1 not found in context');
      }
      const stationAEntity = this.getEntity(context, 'stationA');
      if (!stationAEntity) {
        throw new Error('Entity stationA not found in context');
      }
      console.log('DEBUG: Comparing agv1.location (' + agv1Entity.properties.location + ') with stationA.ID (' + stationAEntity.properties.ID + ')');
      const condition1 = this.compareValues(agv1Entity.properties.location, stationAEntity.properties.ID);
      // Condition 2: part.location == stationA.ID
      const partEntity = this.getEntity(context, 'part');
      console.log('DEBUG: partEntity:', partEntity);
      if (!partEntity) {
        throw new Error('Entity part not found in context');
      }
      console.log('DEBUG: Comparing part.location (' + partEntity.properties.location + ') with stationA.ID (' + stationAEntity.properties.ID + ')');
      const condition2 = this.compareValues(partEntity.properties.location, stationAEntity.properties.ID);

      // All conditions must be satisfied
      const allConditionsMet = condition1 && condition2;
      return allConditionsMet;
    } catch (error) {
      console.error(`Error evaluating post-conditions for ${this.name}:`, error.message);
      return false;
    }
  }
}

// Enhanced Scene: SCN_MoveAGV2toC
class SCN_MoveAGV2toC extends Scene {
  constructor(name = 'SCN_MoveAGV2toC', opts = {}) {
    super(name, {
      ...opts,
      sceneType: 'scene',
      startEvent: 'cmdAGV2toC',
      finishEvent: 'AGV2NotifArriveC',
      entities: [],
      initialStates: {}
    });
  }

  
  validatePreConditions(context) {
    // Enhanced pre-condition validation with context support
    if (!context) {
      throw new Error('Context is required for pre-condition evaluation');
    }

    try {
      // Condition 1: agv2.location == stationD.ID
      const agv2Entity = this.getEntity(context, 'agv2');
      console.log('DEBUG: agv2Entity:', agv2Entity);
      if (!agv2Entity) {
        throw new Error('Entity agv2 not found in context');
      }
      const stationDEntity = this.getEntity(context, 'stationD');
      if (!stationDEntity) {
        throw new Error('Entity stationD not found in context');
      }
      console.log('DEBUG: Comparing agv2.location (' + agv2Entity.properties.location + ') with stationD.ID (' + stationDEntity.properties.ID + ')');
      const condition1 = this.compareValues(agv2Entity.properties.location, stationDEntity.properties.ID);
      // Condition 2: part.location == stationA.ID
      const partEntity = this.getEntity(context, 'part');
      console.log('DEBUG: partEntity:', partEntity);
      if (!partEntity) {
        throw new Error('Entity part not found in context');
      }
      const stationAEntity = this.getEntity(context, 'stationA');
      if (!stationAEntity) {
        throw new Error('Entity stationA not found in context');
      }
      console.log('DEBUG: Comparing part.location (' + partEntity.properties.location + ') with stationA.ID (' + stationAEntity.properties.ID + ')');
      const condition2 = this.compareValues(partEntity.properties.location, stationAEntity.properties.ID);

      // All conditions must be satisfied
      const allConditionsMet = condition1 && condition2;
      return allConditionsMet;
    } catch (error) {
      console.error(`Error evaluating pre-conditions for ${this.name}:`, error.message);
      return false;
    }
  }

  
  validatePostConditions(context) {
    // Enhanced post-condition validation with context support
    if (!context) {
      throw new Error('Context is required for post-condition evaluation');
    }

    try {
      // Condition 1: agv2.location == stationC.ID
      const agv2Entity = this.getEntity(context, 'agv2');
      console.log('DEBUG: agv2Entity:', agv2Entity);
      if (!agv2Entity) {
        throw new Error('Entity agv2 not found in context');
      }
      const stationCEntity = this.getEntity(context, 'stationC');
      if (!stationCEntity) {
        throw new Error('Entity stationC not found in context');
      }
      console.log('DEBUG: Comparing agv2.location (' + agv2Entity.properties.location + ') with stationC.ID (' + stationCEntity.properties.ID + ')');
      const condition1 = this.compareValues(agv2Entity.properties.location, stationCEntity.properties.ID);
      // Condition 2: part.location == stationA.ID
      const partEntity = this.getEntity(context, 'part');
      console.log('DEBUG: partEntity:', partEntity);
      if (!partEntity) {
        throw new Error('Entity part not found in context');
      }
      const stationAEntity = this.getEntity(context, 'stationA');
      if (!stationAEntity) {
        throw new Error('Entity stationA not found in context');
      }
      console.log('DEBUG: Comparing part.location (' + partEntity.properties.location + ') with stationA.ID (' + stationAEntity.properties.ID + ')');
      const condition2 = this.compareValues(partEntity.properties.location, stationAEntity.properties.ID);

      // All conditions must be satisfied
      const allConditionsMet = condition1 && condition2;
      return allConditionsMet;
    } catch (error) {
      console.error(`Error evaluating post-conditions for ${this.name}:`, error.message);
      return false;
    }
  }
}

// Enhanced Scene: SCN_AGV1movePartToC
class SCN_AGV1movePartToC extends Scene {
  constructor(name = 'SCN_AGV1movePartToC', opts = {}) {
    super(name, {
      ...opts,
      sceneType: 'scene',
      startEvent: 'AGV1NotifArriveA',
      finishEvent: 'AGV1detachPartX',
      entities: [],
      initialStates: {}
    });
  }

  
  validatePreConditions(context) {
    // Enhanced pre-condition validation with context support
    if (!context) {
      throw new Error('Context is required for pre-condition evaluation');
    }

    try {
      // Condition 1: agv1.location == stationA.ID
      const agv1Entity = this.getEntity(context, 'agv1');
      console.log('DEBUG: agv1Entity:', agv1Entity);
      if (!agv1Entity) {
        throw new Error('Entity agv1 not found in context');
      }
      const stationAEntity = this.getEntity(context, 'stationA');
      if (!stationAEntity) {
        throw new Error('Entity stationA not found in context');
      }
      console.log('DEBUG: Comparing agv1.location (' + agv1Entity.properties.location + ') with stationA.ID (' + stationAEntity.properties.ID + ')');
      const condition1 = this.compareValues(agv1Entity.properties.location, stationAEntity.properties.ID);
      // Condition 2: part.location == stationA.ID
      const partEntity = this.getEntity(context, 'part');
      console.log('DEBUG: partEntity:', partEntity);
      if (!partEntity) {
        throw new Error('Entity part not found in context');
      }
      console.log('DEBUG: Comparing part.location (' + partEntity.properties.location + ') with stationA.ID (' + stationAEntity.properties.ID + ')');
      const condition2 = this.compareValues(partEntity.properties.location, stationAEntity.properties.ID);

      // All conditions must be satisfied
      const allConditionsMet = condition1 && condition2;
      return allConditionsMet;
    } catch (error) {
      console.error(`Error evaluating pre-conditions for ${this.name}:`, error.message);
      return false;
    }
  }

  
  validatePostConditions(context) {
    // Enhanced post-condition validation with context support
    if (!context) {
      throw new Error('Context is required for post-condition evaluation');
    }

    try {
      // Condition 1: agv1.location == stationC.ID
      const agv1Entity = this.getEntity(context, 'agv1');
      console.log('DEBUG: agv1Entity:', agv1Entity);
      if (!agv1Entity) {
        throw new Error('Entity agv1 not found in context');
      }
      const stationCEntity = this.getEntity(context, 'stationC');
      if (!stationCEntity) {
        throw new Error('Entity stationC not found in context');
      }
      console.log('DEBUG: Comparing agv1.location (' + agv1Entity.properties.location + ') with stationC.ID (' + stationCEntity.properties.ID + ')');
      const condition1 = this.compareValues(agv1Entity.properties.location, stationCEntity.properties.ID);
      // Condition 2: part.location == stationC.ID
      const partEntity = this.getEntity(context, 'part');
      console.log('DEBUG: partEntity:', partEntity);
      if (!partEntity) {
        throw new Error('Entity part not found in context');
      }
      console.log('DEBUG: Comparing part.location (' + partEntity.properties.location + ') with stationC.ID (' + stationCEntity.properties.ID + ')');
      const condition2 = this.compareValues(partEntity.properties.location, stationCEntity.properties.ID);

      // All conditions must be satisfied
      const allConditionsMet = condition1 && condition2;
      return allConditionsMet;
    } catch (error) {
      console.error(`Error evaluating post-conditions for ${this.name}:`, error.message);
      return false;
    }
  }
}

// Enhanced Scene: SCN_AGV2movePartToE
class SCN_AGV2movePartToE extends Scene {
  constructor(name = 'SCN_AGV2movePartToE', opts = {}) {
    super(name, {
      ...opts,
      sceneType: 'scene',
      startEvent: 'AGV2NotifArriveC',
      finishEvent: 'AGV2detachPartX',
      entities: [],
      initialStates: {}
    });
  }

  
  validatePreConditions(context) {
    // Enhanced pre-condition validation with context support
    if (!context) {
      throw new Error('Context is required for pre-condition evaluation');
    }

    try {
      // Condition 1: agv2.location == stationC.ID
      const agv2Entity = this.getEntity(context, 'agv2');
      console.log('DEBUG: agv2Entity:', agv2Entity);
      if (!agv2Entity) {
        throw new Error('Entity agv2 not found in context');
      }
      const stationCEntity = this.getEntity(context, 'stationC');
      if (!stationCEntity) {
        throw new Error('Entity stationC not found in context');
      }
      console.log('DEBUG: Comparing agv2.location (' + agv2Entity.properties.location + ') with stationC.ID (' + stationCEntity.properties.ID + ')');
      const condition1 = this.compareValues(agv2Entity.properties.location, stationCEntity.properties.ID);
      // Condition 2: part.location == stationC.ID
      const partEntity = this.getEntity(context, 'part');
      console.log('DEBUG: partEntity:', partEntity);
      if (!partEntity) {
        throw new Error('Entity part not found in context');
      }
      console.log('DEBUG: Comparing part.location (' + partEntity.properties.location + ') with stationC.ID (' + stationCEntity.properties.ID + ')');
      const condition2 = this.compareValues(partEntity.properties.location, stationCEntity.properties.ID);

      // All conditions must be satisfied
      const allConditionsMet = condition1 && condition2;
      return allConditionsMet;
    } catch (error) {
      console.error(`Error evaluating pre-conditions for ${this.name}:`, error.message);
      return false;
    }
  }

  
  validatePostConditions(context) {
    // Enhanced post-condition validation with context support
    if (!context) {
      throw new Error('Context is required for post-condition evaluation');
    }

    try {
      // Condition 1: agv2.location == stationE.ID
      const agv2Entity = this.getEntity(context, 'agv2');
      console.log('DEBUG: agv2Entity:', agv2Entity);
      if (!agv2Entity) {
        throw new Error('Entity agv2 not found in context');
      }
      const stationEEntity = this.getEntity(context, 'stationE');
      if (!stationEEntity) {
        throw new Error('Entity stationE not found in context');
      }
      console.log('DEBUG: Comparing agv2.location (' + agv2Entity.properties.location + ') with stationE.ID (' + stationEEntity.properties.ID + ')');
      const condition1 = this.compareValues(agv2Entity.properties.location, stationEEntity.properties.ID);
      // Condition 2: part.location == stationE.ID
      const partEntity = this.getEntity(context, 'part');
      console.log('DEBUG: partEntity:', partEntity);
      if (!partEntity) {
        throw new Error('Entity part not found in context');
      }
      console.log('DEBUG: Comparing part.location (' + partEntity.properties.location + ') with stationE.ID (' + stationEEntity.properties.ID + ')');
      const condition2 = this.compareValues(partEntity.properties.location, stationEEntity.properties.ID);

      // All conditions must be satisfied
      const allConditionsMet = condition1 && condition2;
      return allConditionsMet;
    } catch (error) {
      console.error(`Error evaluating post-conditions for ${this.name}:`, error.message);
      return false;
    }
  }
}

// Scene Definitions: MyScenes
class MyScenes extends SceneDefinitions {
  constructor(name = 'MyScenes', opts = {}) {
    super(name, {
      ...opts,
      targetEvents: 'MyEvents',
      scenes: {}
    });
  }
}

class Scenario1 extends Scenario {
  constructor(name = 'Scenario1', opts = {}) {
    super(name, {
      ...opts,
      scenarioType: 'scenario'
    });
  }

  async execute(context) {
    if (!context || !context.scenes) {
      throw new Error('Context with scenes registry is required for scenario execution');
    }

    // Execute scene with logging
    if (context.model?.logger) {
      context.model.logger.logExecution({
        type: 'scene.execution.started',
        name: 'SCN_MoveAGV1toA',
        context: { scenario: this.name },
        trace: { scenario: this.name, sceneName: 'SCN_MoveAGV1toA' }
      });
    }
    const sceneStartTime_SCN_MoveAGV1toA = Date.now();
    await this.executeScene('SCN_MoveAGV1toA', context);
    if (context.model?.logger) {
      context.model.logger.logExecution({
        type: 'scene.execution.completed',
        name: 'SCN_MoveAGV1toA',
        context: { scenario: this.name },
        trace: { scenario: this.name, sceneName: 'SCN_MoveAGV1toA' },
        metrics: { duration: Date.now() - sceneStartTime_SCN_MoveAGV1toA }
      });
    }
    // Notify EventScheduler about scene completion
    if (context.eventScheduler?.notifyScenarioCompleted) {
      context.eventScheduler.notifyScenarioCompleted('SCN_MoveAGV1toA');
    }
    // Execute scene with logging
    if (context.model?.logger) {
      context.model.logger.logExecution({
        type: 'scene.execution.started',
        name: 'SCN_MoveAGV2toC',
        context: { scenario: this.name },
        trace: { scenario: this.name, sceneName: 'SCN_MoveAGV2toC' }
      });
    }
    const sceneStartTime_SCN_MoveAGV2toC = Date.now();
    await this.executeScene('SCN_MoveAGV2toC', context);
    if (context.model?.logger) {
      context.model.logger.logExecution({
        type: 'scene.execution.completed',
        name: 'SCN_MoveAGV2toC',
        context: { scenario: this.name },
        trace: { scenario: this.name, sceneName: 'SCN_MoveAGV2toC' },
        metrics: { duration: Date.now() - sceneStartTime_SCN_MoveAGV2toC }
      });
    }
    // Notify EventScheduler about scene completion
    if (context.eventScheduler?.notifyScenarioCompleted) {
      context.eventScheduler.notifyScenarioCompleted('SCN_MoveAGV2toC');
    }
    // Execute scene with logging
    if (context.model?.logger) {
      context.model.logger.logExecution({
        type: 'scene.execution.started',
        name: 'SCN_AGV1movePartToC',
        context: { scenario: this.name },
        trace: { scenario: this.name, sceneName: 'SCN_AGV1movePartToC' }
      });
    }
    const sceneStartTime_SCN_AGV1movePartToC = Date.now();
    await this.executeScene('SCN_AGV1movePartToC', context);
    if (context.model?.logger) {
      context.model.logger.logExecution({
        type: 'scene.execution.completed',
        name: 'SCN_AGV1movePartToC',
        context: { scenario: this.name },
        trace: { scenario: this.name, sceneName: 'SCN_AGV1movePartToC' },
        metrics: { duration: Date.now() - sceneStartTime_SCN_AGV1movePartToC }
      });
    }
    // Notify EventScheduler about scene completion
    if (context.eventScheduler?.notifyScenarioCompleted) {
      context.eventScheduler.notifyScenarioCompleted('SCN_AGV1movePartToC');
    }
    // Execute scene with logging
    if (context.model?.logger) {
      context.model.logger.logExecution({
        type: 'scene.execution.started',
        name: 'SCN_AGV2movePartToE',
        context: { scenario: this.name },
        trace: { scenario: this.name, sceneName: 'SCN_AGV2movePartToE' }
      });
    }
    const sceneStartTime_SCN_AGV2movePartToE = Date.now();
    await this.executeScene('SCN_AGV2movePartToE', context);
    if (context.model?.logger) {
      context.model.logger.logExecution({
        type: 'scene.execution.completed',
        name: 'SCN_AGV2movePartToE',
        context: { scenario: this.name },
        trace: { scenario: this.name, sceneName: 'SCN_AGV2movePartToE' },
        metrics: { duration: Date.now() - sceneStartTime_SCN_AGV2movePartToE }
      });
    }
    // Notify EventScheduler about scene completion
    if (context.eventScheduler?.notifyScenarioCompleted) {
      context.eventScheduler.notifyScenarioCompleted('SCN_AGV2movePartToE');
    }

    return { success: true, message: 'Scenario completed successfully' };
  }
}

class Scenario2 extends Scenario {
  constructor(name = 'Scenario2', opts = {}) {
    super(name, {
      ...opts,
      scenarioType: 'scenario'
    });
  }

  async execute(context) {
    if (!context || !context.scenes) {
      throw new Error('Context with scenes registry is required for scenario execution');
    }

    // Execute scene with logging
    if (context.model?.logger) {
      context.model.logger.logExecution({
        type: 'scene.execution.started',
        name: 'SCN_MoveAGV1toA',
        context: { scenario: this.name },
        trace: { scenario: this.name, sceneName: 'SCN_MoveAGV1toA' }
      });
    }
    const sceneStartTime_SCN_MoveAGV1toA = Date.now();
    await this.executeScene('SCN_MoveAGV1toA', context);
    if (context.model?.logger) {
      context.model.logger.logExecution({
        type: 'scene.execution.completed',
        name: 'SCN_MoveAGV1toA',
        context: { scenario: this.name },
        trace: { scenario: this.name, sceneName: 'SCN_MoveAGV1toA' },
        metrics: { duration: Date.now() - sceneStartTime_SCN_MoveAGV1toA }
      });
    }
    // Notify EventScheduler about scene completion
    if (context.eventScheduler?.notifyScenarioCompleted) {
      context.eventScheduler.notifyScenarioCompleted('SCN_MoveAGV1toA');
    }
    // Execute scene with logging
    if (context.model?.logger) {
      context.model.logger.logExecution({
        type: 'scene.execution.started',
        name: 'SCN_MoveAGV2toC',
        context: { scenario: this.name },
        trace: { scenario: this.name, sceneName: 'SCN_MoveAGV2toC' }
      });
    }
    const sceneStartTime_SCN_MoveAGV2toC = Date.now();
    await this.executeScene('SCN_MoveAGV2toC', context);
    if (context.model?.logger) {
      context.model.logger.logExecution({
        type: 'scene.execution.completed',
        name: 'SCN_MoveAGV2toC',
        context: { scenario: this.name },
        trace: { scenario: this.name, sceneName: 'SCN_MoveAGV2toC' },
        metrics: { duration: Date.now() - sceneStartTime_SCN_MoveAGV2toC }
      });
    }
    // Notify EventScheduler about scene completion
    if (context.eventScheduler?.notifyScenarioCompleted) {
      context.eventScheduler.notifyScenarioCompleted('SCN_MoveAGV2toC');
    }
    // Execute scene with logging
    if (context.model?.logger) {
      context.model.logger.logExecution({
        type: 'scene.execution.started',
        name: 'SCN_AGV2movePartToE',
        context: { scenario: this.name },
        trace: { scenario: this.name, sceneName: 'SCN_AGV2movePartToE' }
      });
    }
    const sceneStartTime_SCN_AGV2movePartToE = Date.now();
    await this.executeScene('SCN_AGV2movePartToE', context);
    if (context.model?.logger) {
      context.model.logger.logExecution({
        type: 'scene.execution.completed',
        name: 'SCN_AGV2movePartToE',
        context: { scenario: this.name },
        trace: { scenario: this.name, sceneName: 'SCN_AGV2movePartToE' },
        metrics: { duration: Date.now() - sceneStartTime_SCN_AGV2movePartToE }
      });
    }
    // Notify EventScheduler about scene completion
    if (context.eventScheduler?.notifyScenarioCompleted) {
      context.eventScheduler.notifyScenarioCompleted('SCN_AGV2movePartToE');
    }
    // Execute scene with logging
    if (context.model?.logger) {
      context.model.logger.logExecution({
        type: 'scene.execution.started',
        name: 'SCN_AGV1movePartToC',
        context: { scenario: this.name },
        trace: { scenario: this.name, sceneName: 'SCN_AGV1movePartToC' }
      });
    }
    const sceneStartTime_SCN_AGV1movePartToC = Date.now();
    await this.executeScene('SCN_AGV1movePartToC', context);
    if (context.model?.logger) {
      context.model.logger.logExecution({
        type: 'scene.execution.completed',
        name: 'SCN_AGV1movePartToC',
        context: { scenario: this.name },
        trace: { scenario: this.name, sceneName: 'SCN_AGV1movePartToC' },
        metrics: { duration: Date.now() - sceneStartTime_SCN_AGV1movePartToC }
      });
    }
    // Notify EventScheduler about scene completion
    if (context.eventScheduler?.notifyScenarioCompleted) {
      context.eventScheduler.notifyScenarioCompleted('SCN_AGV1movePartToC');
    }

    return { success: true, message: 'Scenario completed successfully' };
  }
}

class Scenario3 extends Scenario {
  constructor(name = 'Scenario3', opts = {}) {
    super(name, {
      ...opts,
      scenarioType: 'scenario'
    });
  }

  async execute(context) {
    if (!context || !context.scenes) {
      throw new Error('Context with scenes registry is required for scenario execution');
    }

    let i = 1;
    while (i < 5) {
      // Execute scene with logging
      if (context.model?.logger) {
        context.model.logger.logExecution({
          type: 'scene.execution.started',
          name: 'SCN_MoveAGV1toA',
          context: { withinLoop: true, scenario: this.name },
          trace: { withinLoop: true, scenario: this.name, sceneName: 'SCN_MoveAGV1toA' }
        });
      }
      const sceneStartTime_SCN_MoveAGV1toA = Date.now();
      await this.executeScene('SCN_MoveAGV1toA', context);
      if (context.model?.logger) {
        context.model.logger.logExecution({
          type: 'scene.execution.completed',
          name: 'SCN_MoveAGV1toA',
          context: { withinLoop: true, scenario: this.name },
          trace: { withinLoop: true, scenario: this.name, sceneName: 'SCN_MoveAGV1toA' },
          metrics: { duration: Date.now() - sceneStartTime_SCN_MoveAGV1toA }
        });
      }
      // Notify EventScheduler about scene completion
      if (context.eventScheduler?.notifyScenarioCompleted) {
        context.eventScheduler.notifyScenarioCompleted('SCN_MoveAGV1toA');
      }
      // Execute scene with logging
      if (context.model?.logger) {
        context.model.logger.logExecution({
          type: 'scene.execution.started',
          name: 'SCN_AGV1movePartToC',
          context: { withinLoop: true, scenario: this.name },
          trace: { withinLoop: true, scenario: this.name, sceneName: 'SCN_AGV1movePartToC' }
        });
      }
      const sceneStartTime_SCN_AGV1movePartToC = Date.now();
      await this.executeScene('SCN_AGV1movePartToC', context);
      if (context.model?.logger) {
        context.model.logger.logExecution({
          type: 'scene.execution.completed',
          name: 'SCN_AGV1movePartToC',
          context: { withinLoop: true, scenario: this.name },
          trace: { withinLoop: true, scenario: this.name, sceneName: 'SCN_AGV1movePartToC' },
          metrics: { duration: Date.now() - sceneStartTime_SCN_AGV1movePartToC }
        });
      }
      // Notify EventScheduler about scene completion
      if (context.eventScheduler?.notifyScenarioCompleted) {
        context.eventScheduler.notifyScenarioCompleted('SCN_AGV1movePartToC');
      }
      i++;
    }

    return { success: true, message: 'Scenario completed successfully' };
  }
}

class Scenario4 extends Scenario {
  constructor(name = 'Scenario4', opts = {}) {
    super(name, {
      ...opts,
      scenarioType: 'scenario'
    });
  }

  async execute(context) {
    if (!context || !context.scenes) {
      throw new Error('Context with scenes registry is required for scenario execution');
    }

    let i = 1;
    while (i < 5) {
      await this.executeScenario('Scenario1', context);
      i++;
    }

    return { success: true, message: 'Scenario completed successfully' };
  }
}

class MyScenarios extends ScenarioDefinitions {
  constructor(name = 'MyScenarios', opts = {}) {
    super(name, {
      ...opts,
      targetScenes: 'MyScenes',
      scenarios: {}
    });

    this.addScenario('Scenario1', Scenario1);
    this.addScenario('Scenario2', Scenario2);
    this.addScenario('Scenario3', Scenario3);
    this.addScenario('Scenario4', Scenario4);
  }
}

// Scenario Execution with Explicit Programming: MyScenariosExecution
class MyScenariosExecution extends ScenarioExecution {
  constructor(name = 'MyScenariosExecution', opts = {}) {
    super(name, {
      ...opts,
      targetScenarios: 'MyScenarios'
    });
  }

  start() {
    console.error('[Generated] start() called for ' + this.name);
    // Build execution context
    const context = this.buildExecutionContext();

    // Execute scenario logic asynchronously
    return this.executeAsync(context).catch(error => {
      if (this.model?.logger) {
        this.model.logger.logExecution({
          type: 'scenario.execution.failed',
          name: this.name,
          context: { error: error.message, stack: error.stack }
        });
      }
      console.error('[ERROR] Scenario execution failed:', error);
    });
  }

  async executeAsync(context) {
    try {
    if (!context || !context.scenarios) {
      throw new Error('Context with scenarios registry is required for scenario execution');
    }

    // Log scenario execution start
    if (context.model?.logger) {
      context.model.logger.logExecution({
        type: 'scenario.execution.started',
        name: this.name,
        context: { executionMode: 'sequential' }
      });
    }
    const executionStartTime = Date.now();

    // Initialize environment state
    if (context.environment) {
      const stationCRef = context.environment.stationC;
      if (stationCRef && stationCRef.properties) {
        console.log('DEBUG: Resolving reference stationC.ID ->', stationCRef.properties.ID);
      // Try to set via EnvPort first (for binding propagation)
      const envPort = context.environment.agv1.getEnvPort ? context.environment.agv1.getEnvPort('location') : null;
      if (envPort) {
        envPort.setValue(stationCRef.properties.ID);
        console.log('DEBUG: Set agv1.location via EnvPort.setValue to', stationCRef.properties.ID);
      } else if (context.environment.agv1 && typeof context.environment.agv1.setProperty === 'function') {
        context.environment.agv1.setProperty('location', stationCRef.properties.ID);
        console.log('DEBUG: Set agv1.location via setProperty to', stationCRef.properties.ID);
      } else if (context.environment.agv1 && context.environment.agv1.properties) {
        context.environment.agv1.properties.location = stationCRef.properties.ID;
        console.log('DEBUG: Set agv1.properties.location to', context.environment.agv1.properties.location);
      } else {
        // Fallback to direct assignment if properties not available
        context.environment.agv1.location = stationCRef.properties.ID;
        console.log('DEBUG: Set agv1.location (direct) to', context.environment.agv1.location);
      }
      } else {
        console.warn('Warning: Could not resolve reference stationC.ID');
      }
    }
    if (context.environment) {
      const stationDRef = context.environment.stationD;
      if (stationDRef && stationDRef.properties) {
        console.log('DEBUG: Resolving reference stationD.ID ->', stationDRef.properties.ID);
      // Try to set via EnvPort first (for binding propagation)
      const envPort = context.environment.agv2.getEnvPort ? context.environment.agv2.getEnvPort('location') : null;
      if (envPort) {
        envPort.setValue(stationDRef.properties.ID);
        console.log('DEBUG: Set agv2.location via EnvPort.setValue to', stationDRef.properties.ID);
      } else if (context.environment.agv2 && typeof context.environment.agv2.setProperty === 'function') {
        context.environment.agv2.setProperty('location', stationDRef.properties.ID);
        console.log('DEBUG: Set agv2.location via setProperty to', stationDRef.properties.ID);
      } else if (context.environment.agv2 && context.environment.agv2.properties) {
        context.environment.agv2.properties.location = stationDRef.properties.ID;
        console.log('DEBUG: Set agv2.properties.location to', context.environment.agv2.properties.location);
      } else {
        // Fallback to direct assignment if properties not available
        context.environment.agv2.location = stationDRef.properties.ID;
        console.log('DEBUG: Set agv2.location (direct) to', context.environment.agv2.location);
      }
      } else {
        console.warn('Warning: Could not resolve reference stationD.ID');
      }
    }
    if (context.environment) {
      const stationARef = context.environment.stationA;
      if (stationARef && stationARef.properties) {
        console.log('DEBUG: Resolving reference stationA.ID ->', stationARef.properties.ID);
      // Try to set via EnvPort first (for binding propagation)
      const envPort = context.environment.part.getEnvPort ? context.environment.part.getEnvPort('location') : null;
      if (envPort) {
        envPort.setValue(stationARef.properties.ID);
        console.log('DEBUG: Set part.location via EnvPort.setValue to', stationARef.properties.ID);
      } else if (context.environment.part && typeof context.environment.part.setProperty === 'function') {
        context.environment.part.setProperty('location', stationARef.properties.ID);
        console.log('DEBUG: Set part.location via setProperty to', stationARef.properties.ID);
      } else if (context.environment.part && context.environment.part.properties) {
        context.environment.part.properties.location = stationARef.properties.ID;
        console.log('DEBUG: Set part.properties.location to', context.environment.part.properties.location);
      } else {
        // Fallback to direct assignment if properties not available
        context.environment.part.location = stationARef.properties.ID;
        console.log('DEBUG: Set part.location (direct) to', context.environment.part.location);
      }
      } else {
        console.warn('Warning: Could not resolve reference stationA.ID');
      }
    }

    // Event injections
    // inject AGV2atStationD after SCN_MoveAGV1toA;
    if (context.eventScheduler) {
      context.eventScheduler.scheduleAfterScenario('AGV2atStationD', 'SCN_MoveAGV1toA');
    }
    // inject SetAGV2SensorStationD when agv1.location == stationA.ID;
    if (context.eventScheduler) {
      context.eventScheduler.scheduleOnCondition('SetAGV2SensorStationD', () => context.model?.environmentConfig?.agv1?.location == context.model?.environmentConfig?.stationA?.ID);
    }
    // inject AGV1atStationA after cmdAGV1toA;
    if (context.eventScheduler) {
      context.eventScheduler.scheduleAfterScenario('AGV1atStationA', 'cmdAGV1toA');
    }

    // Execute scenarios
    await this.executeScenario('Scenario1', context);
    await this.executeScenario('Scenario2', context);
    await this.executeScenario('Scenario3', context);
    await this.executeScenario('Scenario4', context);

    // Repeat executions
    for (let i = 0; i < 5; i++) {
      await this.executeScenario('Scenario1', context);
    }

    // Log scenario execution completion
    if (context.model?.logger) {
      context.model.logger.logExecution({
        type: 'scenario.execution.completed',
        name: this.name,
        context: { executionMode: 'sequential' },
        metrics: { duration: Date.now() - executionStartTime }
      });
    }

    return { success: true, message: 'Scenario execution completed successfully' };
    } catch (error) {
      throw error;
    }
  }
}

function createEnvironmentModel() {
  const model = createModel(); // Get traditional model
  
  // Initialize scenario execution capabilities
  model.initializeScenarioExecution();
  
  // Add environment/scenario elements to model
  model.environments = {};
  model.events = {};
  model.scenes = {};
  model.scenarios = {};
  model.scenarioExecutions = {};
  
  model.environments['MyFactory'] = new MyFactory();
  model.environments['MyFactoryConfiguration'] = new MyFactoryConfiguration();
  model.events['MyEvents'] = new MyEvents();
  model.scenes['MyScenes'] = new MyScenes();
  model.scenarios['MyScenarios'] = new MyScenarios();
  model.scenes['SCN_MoveAGV1toA'] = SCN_MoveAGV1toA;
  model.scenes['SCN_MoveAGV2toC'] = SCN_MoveAGV2toC;
  model.scenes['SCN_AGV1movePartToC'] = SCN_AGV1movePartToC;
  model.scenes['SCN_AGV2movePartToE'] = SCN_AGV2movePartToE;
  model.scenarios['Scenario1'] = Scenario1;
  model.scenarios['Scenario2'] = Scenario2;
  model.scenarios['Scenario3'] = Scenario3;
  model.scenarios['Scenario4'] = Scenario4;
  model.scenarioExecutions['MyScenariosExecution'] = new MyScenariosExecution();
  model.registerScenarioExecution(model.scenarioExecutions['MyScenariosExecution']);
  
  // Setup environment bindings if needed
  // TODO: Implement automatic binding setup based on model analysis
  
  return model;
}

module.exports = { createEnvironmentModel, MyFactory, MyFactoryConfiguration, MyEvents, MyScenes, MyScenarios, MyScenariosExecution, SCN_MoveAGV1toA, SCN_MoveAGV2toC, SCN_AGV1movePartToC, SCN_AGV2movePartToE, Scenario1, Scenario2, Scenario3, Scenario4 };